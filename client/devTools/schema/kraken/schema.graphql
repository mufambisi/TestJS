"""
This class inherits from multiple Queries as we add more apps to the API.
"""
type Query {
  """Lists of high rank and normal quoted products"""
  quotedProducts(input: QuotedProductSearchInputType!): QuotedProductsDisplayType
  surchargeAmount(accountNumber: String!, amount: Int!, ledgerId: Int, cardScheme: CardPaymentNetwork, cardType: CardType): Int!

  """Details about the fee eligibility and the merchant code"""
  feeEligibilityDetails(accountNumber: String, reference: String): FeeEligibilityDetailsType

  """Find NMI from aemo"""
  nmiDiscovery(input: NMIDiscoveryAddressInput): NMIDiscoveryType

  """
  
  Check status for nmi.
  
  If nmi is not found nmiCheck will be null
  
  """
  nmiCheck(nmi: String!): NMICheckType

  """Get meter point details"""
  meterPoint(nmi: String!): MeterPointInterface

  """
   
  Fetch electricity meter readings for a given account and meter.
  Optionally include readings that have been quarantined (these are
  excluded by default)
  
  Each reading here is actually a group of all the readings
  which happened at the same date and time on that meter.
  
  The reason for this is that end users typically don't care
  about registers, and simply want to view all their meter
  readings in chronological order.
   
  
   
  
  This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).
  
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  electricityMeterReadings(
    accountNumber: String
    meterId: String!
    includeQuarantined: Boolean = false

    """Start time/date for the date range to filter readings"""
    startAt: String

    """End time/date for the date range to filter readings"""
    endAt: String
    before: String
    after: String
    first: Int
    last: Int
  ): ElectricityMeterReadingConnectionTypeConnection

  """
   
  Fetch daily summaries of electricity meter readings for a
  given account and meter.
  Optionally include readings that have been quarantined (these are
  excluded by default).
  Days where no meter readings occurred will be omitted.
  This query has been deprecated, please use the electricityMeterReadingsSummary()
  instead.
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  electricityMeterReadingsDaily(
    accountNumber: String
    meterId: String!

    """Readings which happened before the start of this day will be excluded."""
    startDate: Date!

    """Readings which happened after the end of this day will be excluded."""
    endDate: Date!
    includeQuarantined: Boolean = false
  ): [DailyElectricityMeterReadingType] @deprecated(reason: "Please use the readingsSummary() property from the ElectricityRegisterType object instead.")

  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType

  """
  Retrieve property information by either property or associated MIRN identifier
  """
  property(id: ID, mirn: ID): PropertyType
  properties(accountNumber: String!, active: Boolean): [PropertyType]
  electricityProduct(code: String!, networkTariffCode: String): Product @deprecated(reason: "Use `product` instead")
  product(
    code: String!

    """Applies only for Electricity products"""
    networkTariffCode: String
  ): Product

  """
   
  **⚠️ This query is currently in preview. During this time, it
  may change without warning in backwards-incompatible
  ways.**
  
  Account User Search
  -------------------
  
  This query returns an AccountUserType attempting to match against the request.
  We attempt to find a user with a close or exact match to the fields provided
  with a confidence score >= that of the `threshold` argument, if `threshold`
  isn't provided we use a internal base threshold of 0.55
  tweak this parameter if you are not getting results as you'd expect.
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  accountUserSearch(input: AccountUserSearchInputType): AccountUserType!

  """Get details about an account."""
  account(accountNumber: String!): AccountType

  """Link object for an affiliate organization."""
  affiliateLink(
    """The affiliate link subdomain."""
    subdomain: String!
  ): AffiliateLinkType!

  """Get the active terms and conditions for a product."""
  termsAndConditionsForProduct(productCode: String!): TermsAndConditionsType

  """Return a signup referral reward scheme with the given code."""
  domesticSignupRewardScheme(code: String!): ReferralSchemeType

  """Return a referral reward scheme for the given account referral code."""
  domesticAccountReferralRewardScheme(code: String!): ReferralSchemeType

  """
  Return the current active signup referral reward scheme with the given code, if any exists.
  """
  activeDomesticSignupRewardScheme: ReferralSchemeType

  """Get deposit agreements for a given account."""
  depositAgreements(accountNumber: String!): [DepositAgreementOutput]

  """Get the default payment instruction for the account's main ledger."""
  defaultPaymentInstruction(
    """The account number."""
    accountNumber: String!

    """Provide an option to get either a CARD or DIRECT_DEBIT instruction."""
    instructionType: PaymentType
  ): PaymentInstructionType

  """Metadata for a linked object."""
  metadata(linkedObjectType: LinkedObjectType, identifier: String!): [Metadata]

  """Metadata for a linked object with key."""
  metadataForKey(linkedObjectType: LinkedObjectType, identifier: String!, key: String!): Metadata

  """Get the customer feedback survey question."""
  question(formId: Int!): String

  """Get default raw score for a customer feedback form."""
  defaultRawScore(formId: Int!): Int

  """list of matching account references"""
  accountReference(value: String): [AccountReferenceType]

  """The ID of the object"""
  node(id: ID!): Node
}

type QuotedProductsDisplayType {
  """The most popular products ordered by rank."""
  highlyRankedProducts: [QuotedProductDisplayType]

  """Remaining non highly ranked products."""
  products: [QuotedProductDisplayType]
  error: QuotedProductsQueryErrorUnion
}

type QuotedProductDisplayType {
  id: ID!
  name: String!
  code: String!
  description: String!
  monthlyAmount: String!
  annualAmount: String!
  availabilityStatus: String!
  primaryUsage: [String]!
  primarySupplyCharge: [String]!
  secondaryUsage: [String]!
  secondarySupplyCharge: [String]!
  solarUsage: [String]!
  solarSupplyCharge: [String]!
  dmoInfo: MarketSupplyProductDisplayType!
}

type MarketSupplyProductDisplayType {
  id: ID!
  availableTo: DateTime
  description: String!
  contractType: String!
  extraInfo: [String]!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

union QuotedProductsQueryErrorUnion = MeterPointDoesNotExistsErrorType | QuoteDoesNotExistsErrorType | BadMeterPointNMIStatusErrorType | QuotedProductsQueryValueErrorType

type MeterPointDoesNotExistsErrorType implements GenericErrorInterfaceType {
  message: String!
}

"""
Generic interface intended to be implemented on kraken error types.
The use case is to translate specific python exceptions into Graphql error
types that are easily parsable by clients while retaining verbose message
outputs

Usage:
    class SpecificExceptionErrorType(graphene.ObjectType):
        class Meta:
            interfaces = [GenericErrorInterfaceType]

    ...
    class SpecificExceptionErrorUnion(graphene.Union):
        class Meta:
            types = [
                SpecificExceptionErrorType,
                ...
            ]

    ...
    class SomeMutation(graphene.Mutation):
        error = graphene.Field(SpecificExceptionErrorUnion)
"""
interface GenericErrorInterfaceType {
  message: String!
}

type QuoteDoesNotExistsErrorType implements GenericErrorInterfaceType {
  message: String!
}

type BadMeterPointNMIStatusErrorType implements GenericErrorInterfaceType {
  message: String!
}

type QuotedProductsQueryValueErrorType implements GenericErrorInterfaceType {
  message: String!
}

input QuotedProductSearchInputType {
  meterPointId: Int!
  quoteId: Int!
}

"""An enumeration."""
enum CardPaymentNetwork {
  MASTERCARD
  VISA
  AMEX
  JCB
  DISCOVER
}

"""An enumeration."""
enum CardType {
  CREDIT
  DEBIT
  PREPAID
}

type FeeEligibilityDetailsType {
  """Whether fees will be charged or not"""
  isFeeEligible: Boolean!

  """Merchant code that will be used"""
  merchantCode: String!
}

type NMIDiscoveryType {
  nmi: String
  rawAemoResponse: String
}

input NMIDiscoveryAddressInput {
  houseNumber: String!
  houseNumberSuffix: String
  streetName: String!
  streetType: StreetType!
  suburbLocality: String
  stateTerritory: StateTerritory!
  postcode: String!
  streetSuffix: StreetSuffix
  flatUnitType: FlatUnitType
  flatUnitNumber: String
  floorType: FloorLevelType
  floorNumber: String
  buildingName: String
  locationDescriptor: String
  jurisdictionCode: Jurisdiction!
}

"""An enumeration."""
enum StreetType {
  """Access"""
  ACCESS

  """Acre (ACRE)"""
  ACRE

  """Alley"""
  ALLEY

  """Alleyway"""
  ALLEYWAY

  """Amble"""
  AMBLE

  """Anchorage"""
  ANCHORAGE

  """Approach"""
  APPROACH

  """Arcade"""
  ARCADE

  """Arterial"""
  ARTERIAL

  """Artery"""
  ARTERY

  """Avenue"""
  AVENUE

  """Banan"""
  BANAN

  """Bank (BANK)"""
  BANK

  """Basin"""
  BASIN

  """Bay (BAY)"""
  BAY

  """Beach"""
  BEACH

  """Bende"""
  BENDE

  """Block"""
  BLOCK

  """Boardwalk"""
  BOARDWALK

  """Boulevard"""
  BOULEVARD

  """Boulevarde"""
  BOULEVARDE

  """Bowl (BOWL)"""
  BOWL

  """Brace"""
  BRACE

  """Brae (BRAE)"""
  BRAE

  """Branch"""
  BRANCH

  """Break"""
  BREAK

  """Brett"""
  BRETT

  """Bridge"""
  BRIDGE

  """Broadway"""
  BROADWAY

  """Brow (BROW)"""
  BROW

  """Bypass"""
  BYPASS

  """Byway"""
  BYWAY

  """Causeway"""
  CAUSEWAY

  """Centre"""
  CENTRE

  """Centreway"""
  CENTREWAY

  """Chase"""
  CHASE

  """Circle"""
  CIRCLE

  """Circlet"""
  CIRCLET

  """Circuit"""
  CIRCUIT

  """Circus"""
  CIRCUS

  """Close"""
  CLOSE

  """Cluster"""
  CLUSTER

  """Colonnade"""
  COLONNADE

  """Common"""
  COMMON

  """Concord"""
  CONCORD

  """Concourse"""
  CONCOURSE

  """Connection"""
  CONNECTION

  """Copse"""
  COPSE

  """Corner"""
  CORNER

  """Corso"""
  CORSO

  """Course"""
  COURSE

  """Court"""
  COURT

  """Courtyard"""
  COURTYARD

  """Cove (COVE)"""
  COVE

  """Crescent"""
  CRESCENT

  """Crest"""
  CREST

  """Crief"""
  CRIEF

  """Crook"""
  CROOK

  """Cross"""
  CROSS

  """Crossing"""
  CROSSING

  """Crossroad"""
  CROSSROAD

  """Crossway"""
  CROSSWAY

  """Cruiseway"""
  CRUISEWAY

  """Cul De Sac"""
  CUL_DE_SAC

  """Cut (CUT)"""
  CUT

  """Cutting"""
  CUTTING

  """Dale (DALE)"""
  DALE

  """Dash (DASH)"""
  DASH

  """Dell (DELL)"""
  DELL

  """Dene (DENE)"""
  DENE

  """Deviation"""
  DEVIATION

  """Dip (DIP)"""
  DIP

  """Distributor"""
  DISTRIBUTOR

  """Divide"""
  DIVIDE

  """Dock (DOCK)"""
  DOCK

  """Domain"""
  DOMAIN

  """Down (DOWN)"""
  DOWN

  """Downs"""
  DOWNS

  """Drive"""
  DRIVE

  """Driveway"""
  DRIVEWAY

  """Easement"""
  EASEMENT

  """Edge (EDGE)"""
  EDGE

  """Elbow"""
  ELBOW

  """End (END)"""
  END

  """Entrance"""
  ENTRANCE

  """Esplanade"""
  ESPLANADE

  """Estate"""
  ESTATE

  """Expressway"""
  EXPRESSWAY

  """Extension"""
  EXTENSION

  """Fairway"""
  FAIRWAY

  """Fire Track"""
  FIRE_TRACK

  """Firebreak"""
  FIREBREAK

  """Fireline"""
  FIRELINE

  """Firetrail"""
  FIRETRAIL

  """Flat (FLAT)"""
  FLAT

  """Flats"""
  FLATS

  """Follow"""
  FOLLOW

  """Footway"""
  FOOTWAY

  """Ford (FORD)"""
  FORD

  """Foreshore"""
  FORESHORE

  """Fork"""
  FORK

  """Formation"""
  FORMATION

  """Freeway"""
  FREEWAY

  """Front"""
  FRONT

  """Frontage"""
  FRONTAGE

  """Gap (GAP)"""
  GAP

  """Garden"""
  GARDEN

  """Gardens"""
  GARDENS

  """Gate"""
  GATE

  """Gates"""
  GATES

  """Gateway"""
  GATEWAY

  """Glade"""
  GLADE

  """Glen (GLEN)"""
  GLEN

  """Grange"""
  GRANGE

  """Green"""
  GREEN

  """Ground"""
  GROUND

  """Grove"""
  GROVE

  """Gully"""
  GULLY

  """Harbour"""
  HARBOUR

  """Haven"""
  HAVEN

  """Heath"""
  HEATH

  """Heights"""
  HEIGHTS

  """Highroad"""
  HIGHROAD

  """Highway"""
  HIGHWAY

  """Hill (HILL)"""
  HILL

  """Hollow"""
  HOLLOW

  """Hub (HUB)"""
  HUB

  """Inlet"""
  INLET

  """Interchange"""
  INTERCHANGE

  """Intersection"""
  INTERSECTION

  """Island"""
  ISLAND

  """Junction"""
  JUNCTION

  """Key (KEY)"""
  KEY

  """Keys (KEYS)"""
  KEYS

  """Knoll"""
  KNOLL

  """Ladder"""
  LADDER

  """Landing"""
  LANDING

  """Lane (LANE)"""
  LANE

  """Laneway"""
  LANEWAY

  """Lead (LEAD)"""
  LEAD

  """Leader"""
  LEADER

  """Lees (LEES)"""
  LEES

  """Line (LINE)"""
  LINE

  """Link (LINK)"""
  LINK

  """Little"""
  LITTLE

  """Lookout"""
  LOOKOUT

  """Loop (LOOP)"""
  LOOP

  """Lower"""
  LOWER

  """Lynne"""
  LYNNE

  """Mall (MALL)"""
  MALL

  """Manor"""
  MANOR

  """Mart (MART)"""
  MART

  """Mead (MEAD)"""
  MEAD

  """Meander"""
  MEANDER

  """Mew (MEW)"""
  MEW

  """Mews (MEWS)"""
  MEWS

  """Mile (MILE)"""
  MILE

  """Motorway"""
  MOTORWAY

  """Mount"""
  MOUNT

  """Nook (NOOK)"""
  NOOK

  """North"""
  NORTH

  """Null (NULL)"""
  NULL

  """Outlet"""
  OUTLET

  """Outlook"""
  OUTLOOK

  """Oval (OVAL)"""
  OVAL

  """Palms"""
  PALMS

  """Parade"""
  PARADE

  """Paradise"""
  PARADISE

  """Park (PARK)"""
  PARK

  """Parklands"""
  PARKLANDS

  """Parkway"""
  PARKWAY

  """Part (PART)"""
  PART

  """Pass (PASS)"""
  PASS

  """Passage"""
  PASSAGE

  """Path (PATH)"""
  PATH

  """Pathway"""
  PATHWAY

  """Peninsula"""
  PENINSULA

  """Piazza"""
  PIAZZA

  """Place"""
  PLACE

  """Plateau"""
  PLATEAU

  """Plaza"""
  PLAZA

  """Pocket"""
  POCKET

  """Point"""
  POINT

  """Port (PORT)"""
  PORT

  """Precinct"""
  PRECINCT

  """Promenade"""
  PROMENADE

  """Pursuit"""
  PURSUIT

  """Quad (QUAD)"""
  QUAD

  """Quadrangle"""
  QUADRANGLE

  """Quadrant"""
  QUADRANT

  """Quay"""
  QUAY

  """Quays"""
  QUAYS

  """Ramble"""
  RAMBLE

  """Ramp (RAMP)"""
  RAMP

  """Range"""
  RANGE

  """Reach"""
  REACH

  """Reef (REEF)"""
  REEF

  """Reserve"""
  RESERVE

  """Rest (REST)"""
  REST

  """Retreat"""
  RETREAT

  """Return"""
  RETURN

  """Ride (RIDE)"""
  RIDE

  """Ridge"""
  RIDGE

  """Ridgeway"""
  RIDGEWAY

  """Right Of Way"""
  RIGHT_OF_WAY

  """Ring (RING)"""
  RING

  """Rise (RISE)"""
  RISE

  """Rising"""
  RISING

  """River"""
  RIVER

  """Riverway"""
  RIVERWAY

  """Riviera"""
  RIVIERA

  """Road"""
  ROAD

  """Roads"""
  ROADS

  """Roadside"""
  ROADSIDE

  """Roadway"""
  ROADWAY

  """Ronde"""
  RONDE

  """Rosebowl"""
  ROSEBOWL

  """Rotary"""
  ROTARY

  """Round"""
  ROUND

  """Route"""
  ROUTE

  """Row (ROW)"""
  ROW

  """Rowe (ROWE)"""
  ROWE

  """Rue (RUE)"""
  RUE

  """Run (RUN)"""
  RUN

  """Service Way"""
  SERVICE_WAY

  """Shunt"""
  SHUNT

  """Siding"""
  SIDING

  """Skyline"""
  SKYLINE

  """Slope"""
  SLOPE

  """Sound"""
  SOUND

  """South"""
  SOUTH

  """Spur (SPUR)"""
  SPUR

  """Square"""
  SQUARE

  """Stairs"""
  STAIRS

  """State Highway"""
  STATE_HIGHWAY

  """Steps"""
  STEPS

  """Straight"""
  STRAIGHT

  """Strait"""
  STRAIT

  """Strand"""
  STRAND

  """Street"""
  STREET

  """Strip"""
  STRIP

  """Subway"""
  SUBWAY

  """Tarn (TARN)"""
  TARN

  """Terrace"""
  TERRACE

  """Thoroughfare"""
  THOROUGHFARE

  """Throughway"""
  THROUGHWAY

  """Tollway"""
  TOLLWAY

  """Top (TOP)"""
  TOP

  """Tor (TOR)"""
  TOR

  """Towers"""
  TOWERS

  """Track"""
  TRACK

  """Trail"""
  TRAIL

  """Trailer"""
  TRAILER

  """Tramway"""
  TRAMWAY

  """Traverse"""
  TRAVERSE

  """Triangle"""
  TRIANGLE

  """Trunkway"""
  TRUNKWAY

  """Tunnel"""
  TUNNEL

  """Turn (TURN)"""
  TURN

  """Underpass"""
  UNDERPASS

  """Upper"""
  UPPER

  """Vale (VALE)"""
  VALE

  """Valley"""
  VALLEY

  """Viaduct"""
  VIADUCT

  """View (VIEW)"""
  VIEW

  """Views"""
  VIEWS

  """Villa"""
  VILLA

  """Village"""
  VILLAGE

  """Villas"""
  VILLAS

  """Vista"""
  VISTA

  """Vue (VUE)"""
  VUE

  """Wade (WADE)"""
  WADE

  """Walk (WALK)"""
  WALK

  """Walkway"""
  WALKWAY

  """Waters"""
  WATERS

  """Waterway"""
  WATERWAY

  """Way (WAY)"""
  WAY

  """Whrf (WHRF)"""
  WHRF

  """Wood (WOOD)"""
  WOOD

  """Woods"""
  WOODS

  """Wynd (WYND)"""
  WYND

  """Yard (YARD)"""
  YARD
}

"""An enumeration."""
enum StateTerritory {
  """Australian Capital Territory"""
  AUSTRALIAN_CAPITAL_TERRITORY

  """New South Wales"""
  NEW_SOUTH_WALES

  """Northern Territory"""
  NORTHERN_TERRITORY

  """Queensland"""
  QUEENSLAND

  """South Australia"""
  SOUTH_AUSTRALIA

  """Tasmania"""
  TASMANIA

  """Victoria"""
  VICTORIA

  """Western Australia"""
  WESTERN_AUSTRALIA
}

"""An enumeration."""
enum StreetSuffix {
  """Central"""
  CENTRAL

  """Deviation"""
  DEVIATION

  """East"""
  EAST

  """Extension"""
  EXTENSION

  """Inner"""
  INNER

  """Lower"""
  LOWER

  """Mall"""
  MALL

  """North"""
  NORTH

  """North East"""
  NORTH_EAST

  """North West"""
  NORTH_WEST

  """Off"""
  OFF

  """On (ON)"""
  ON

  """Outer"""
  OUTER

  """Overpass"""
  OVERPASS

  """South"""
  SOUTH

  """South East"""
  SOUTH_EAST

  """South West"""
  SOUTH_WEST

  """Upper"""
  UPPER

  """West"""
  WEST
}

"""An enumeration."""
enum FlatUnitType {
  """Antenna"""
  ANTENNA

  """Apartment"""
  APARTMENT

  """Automated Teller Machine (ATM)"""
  ATM

  """Barbecue"""
  BARBECUE

  """Block"""
  BLOCK

  """Boatshed"""
  BOATSHED

  """Building"""
  BUILDING

  """Bungalow"""
  BUNGALOW

  """Cage (CAGE)"""
  CAGE

  """Carpark"""
  CARPARK

  """Carspace"""
  CARSPACE

  """Club (CLUB)"""
  CLUB

  """Coolroom"""
  COOLROOM

  """Cottage"""
  COTTAGE

  """Duplex"""
  DUPLEX

  """Factory"""
  FACTORY

  """Flat"""
  FLAT

  """Garage"""
  GARAGE

  """Hall (HALL)"""
  HALL

  """House"""
  HOUSE

  """Kiosk"""
  KIOSK

  """Lease"""
  LEASE

  """Lobby"""
  LOBBY

  """Loft (LOFT)"""
  LOFT

  """Lot (LOT)"""
  LOT

  """Maisonette"""
  MAISONETTE

  """Marine Berth"""
  MARINE_BERTH

  """Office"""
  OFFICE

  """Penthouse"""
  PENTHOUSE

  """Rear (REAR)"""
  REAR

  """Reserve"""
  RESERVE

  """Room"""
  ROOM

  """Section"""
  SECTION

  """Shed (SHED)"""
  SHED

  """Shop (SHOP)"""
  SHOP

  """Showroom"""
  SHOWROOM

  """Sign (SIGN)"""
  SIGN

  """Site (SITE)"""
  SITE

  """Stall"""
  STALL

  """Store"""
  STORE

  """Strata Unit"""
  STRATA_UNIT

  """Studio"""
  STUDIO

  """Substation"""
  SUBSTATION

  """Suite"""
  SUITE

  """Tenancy"""
  TENANCY

  """Tower"""
  TOWER

  """Townhouse"""
  TOWNHOUSE

  """Unit"""
  UNIT

  """Vault"""
  VAULT

  """Villa"""
  VILLA

  """Ward (WARD)"""
  WARD

  """Warehouse"""
  WAREHOUSE

  """Workshop"""
  WORKSHOP
}

"""An enumeration."""
enum FloorLevelType {
  """Basement"""
  BASEMENT

  """Floor"""
  FLOOR

  """Ground Floor"""
  GROUND_FLOOR

  """Level"""
  LEVEL

  """Lobby"""
  LOBBY

  """Lower Ground"""
  LOWER_GROUND

  """Mezzanine"""
  MEZZANINE

  """Observation Deck"""
  OBSERVATION_DECK

  """Parking"""
  PARKING

  """Rooftop"""
  ROOFTOP

  """Sub Basement"""
  SUB_BASEMENT

  """Upper Ground Floor"""
  UPPER_GROUND_FLOOR
}

"""An enumeration."""
enum Jurisdiction {
  """All Jurisdictions"""
  ALL_JURISDICTIONS

  """National Electricity Market"""
  NATIONAL_ELECTRICITY_MARKET

  """Australian Capital Territory"""
  AUSTRALIAN_CAPITAL_TERRITORY

  """New South Wales"""
  NEW_SOUTH_WALES

  """Queensland"""
  QUEENSLAND

  """South Australia"""
  SOUTH_AUSTRALIA

  """Tasmania"""
  TASMANIA

  """Victoria"""
  VICTORIA
}

type NMICheckType {
  """Whether the NMI searched for is currently on supply"""
  isOnSupply: Boolean

  """
  Meter point Status for the NMI in Kraken. It will be null if the NMI is not on supply.
  """
  krakenStatus: KrakenStatus

  """
  Date since when the NMI is on supply. It will be null if the NMI is not on supply.
  """
  supplyStartDate: Date

  """
  Whether the account associated with NMI is an occupier account. This will be null if there is no linked account.
  """
  isOccupier: Boolean

  """
  The account number associated with the NMI. This will be null if there is no linked account
  """
  accountNumber: String
}

"""An enumeration."""
enum KrakenStatus {
  OFF_SUPPLY
  ON_SUPPLY
  GAINING
  LOSING
  LOST
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""Interface for common fields for Aus Electricity and Gas Meterpoints."""
interface MeterPointInterface {
  status: String

  """Returns all meters by default, but can be filtered by meter id."""
  meters(id: Int): [Meter]

  """
  Details about an enrolment of this meter point. Will be null if no enrolment is taking place.
  """
  enrolment: EnrolmentType
  id: Int
  identifier: String
  supplyStatus: KrakenStatus

  """
  A list of agreements belonging to an account that is linked to the logged in user.
  """
  agreements(includeInactive: Boolean = true): [AgreementInterface]

  """The fuel/service type for this meter point."""
  supplyType: String
}

interface Meter {
  id: ID!
  serialNumber: String!

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
}

"""Pagination for energy consumption readings."""
type ConsumptionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ConsumptionEdge]!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `Consumption` and its cursor."""
type ConsumptionEdge {
  """The item at the end of the edge"""
  node: ConsumptionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Energy consumption between two points in time."""
type ConsumptionType {
  value: Decimal
  startAt: DateTime
  endAt: DateTime
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

"""An enumeration."""
enum ConsumptionGroupings {
  HALF_HOUR
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

"""Details of an ongoing enrolment process."""
type EnrolmentType {
  """Date the switch started."""
  switchStartDate: Date

  """Target date for supply to start."""
  supplyStartDate: Date

  """
  
  
  PRE_REGISTRATION can transition to the following statuses:️ INITIATED.
  
  INITIATED can transition to the following statuses:️ REJECTED, PENDING_VALIDATION, CANCELLED, REQUESTED.
  
  PENDING_VALIDATION can transition to the following statuses:️ REQUESTED, REJECTED, CANCELLED, PENDING_CANCELLATION, OBJECTED, PENDING.
  
  REQUESTED can transition to the following statuses:️ PENDING, COMPLETED, OBJECTED, REJECTED, CANCELLED, PENDING_CANCELLATION, PENDING_VALIDATION.
  
  OBJECTED can transition to the following statuses:️ REQUESTED, CANCELLED, PENDING_CANCELLATION, OBJECTION_WITHDRAWN.
  
  REJECTED can transition to the following statuses:️ REJECTED.
  
  WITHDRAWN is a terminal status.
  
  PENDING can transition to the following statuses:️ COMPLETED, CANCELLED, PENDING_CANCELLATION, OBJECTED, REJECTED.
  
  COMPLETED is a terminal status.
  
  CANCELLED is a terminal status.
  
  PENDING_CANCELLATION can transition to the following statuses:️ CANCELLED.
  
  OBJECTION_WITHDRAWN can transition to the following statuses:️ REQUESTED, OBJECTED.
  """
  status: ChangeOfSupplierStatusOptions
}

"""An enumeration."""
enum ChangeOfSupplierStatusOptions {
  """
  Initiation is the first status of a new change of supplier request. During this status, the initiating participant send an appropriate change reason code to MSATS. MSATS will then validate the change request prior to changing the status to ```PENDING_VALIDATION``` status. 
  """
  INITIATED

  """
  The Pending Validation status commences after the Change Request has passed initial validation for entry into MSATS. However, not all the data that is required to initiate the transaction may be present in MSATS. If mandatory data is missing from the Change Request, the Change Request will be Rejected. If the missing data is for the NMI Master Record, a Data Request will be sent to the nominated Participant, and MSATS will check for the receipt of that data. There is no time limit imposed by MSATS for the provision of this data, however, the Participant that receives the Data Request must respond in a reasonable time. The Change Request will be approved only after all required data has been submitted. 
  """
  PENDING_VALIDATION

  """
  The Rejected status occurs where a Change Request has failed validation. This can occur: 
  
   - During the validation of a Change Request whilst it is at the ```PENDING_VALIDATION``` status; or 
  
   - At the time of completion of the Change Request (in rare circumstances where a change to some other data made after this Change Request was submitted has now made this change invalid). 
  
   When a transaction has been Rejected, all Participants associated with the transaction will be notified in accordance with the Change Request Status Notification Rules. 
  """
  REJECTED

  """
  The Requested status is where a transaction has been validated, i.e. there is no missing data. Notifications of the Requested transaction are sent to the relevant Participants. The Objection Logging Period and Objection Clearing Periods have been identified. Any Objections received are validated against the Objection Rules or no Objections have been submitted.
  """
  REQUESTED

  """
  The Objected status occurs where one or more Objections have been received. Notifications of the Objections are sent to the relevant parties. This includes details of the Objections and whether the transaction was already being Objected to. When an Objection is withdrawn, the relevant parties will be notified of the details of the withdrawn Objection. When the last Objection is withdrawn, the transaction status changes back to ```REQUESTED```, unless the Objection Logging Period has expired, in which case it will move to Pending status. If the Objection Clearing Period has expired and an Objection that is subject to the Objection Logging Period has not been withdrawn the status will be changed to ```CANCELLED```.
  """
  OBJECTED

  """
  The Pending status is where no Objections have been received, or all Objections have been withdrawn and the Objection period has passed. The transaction is waiting for the change date to be reached. If the Proposed Change Date is reached and all required data is present, the status will change to ```COMPLETED```. The status will remain ```PENDING``` whilst any required data remains outstanding or an Objection that is not subject to the Objection Logging Period is not raised. Notifications are sent to the relevant Participants in accordance with the Change Request Status Notification Rules.
  """
  PENDING

  """
  The Completed status occurs where the Objection Logging Period has passed, all required data is present in MSATS and the Proposed Change Date has been reached or is passed. Notifications are sent to the relevant Participants in accordance with the Change Request Status Notification Rules.
  """
  COMPLETED

  """
  The Cancelled status occurs where:  
  
   - Not all Objections have been withdrawn at expiry of the Objection Clearing Period; or 
  
   - The initiator of the Change Request has withdrawn the transaction. 
  
   When a Change Request is Cancelled, notifications are sent to the relevant Participants in accordance with the Change Request Status Notification Rules. 
  """
  CANCELLED

  """
  The meterpoint has been enrolled but the change request has not been sent yet (as the cooling off period is still active)
  """
  PRE_REGISTRATION

  """
  The enrolment was started and then either the customer or a staff member has withdrawn it.
  """
  WITHDRAWN

  """
  If the account is withdrawn after the change request is sent, the meter points will have this status until we get a response to the request to withdraw.
  """
  CANCELLATION_REQUESTED

  """A raised objection was withdrawn and the change request will continue."""
  OBJECTION_WITHDRAWN
}

interface AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
  product: Product
  supplyType: String
  isActive: String
  meterPoint: MeterPointInterface
}

type Product {
  rates: [Rate] @deprecated(reason: "Please use `productRates` instead.")
  productRates: [RateInterface]
  code: String
  displayName: String
  description: String
  isStandingOffer: Boolean
  marketName: MarketName
}

"""
Product rates may be matched to registers using the network tariff code and time of day.
"""
type Rate {
  """Accumulation meters use the `ALLDAY` product rates."""
  timeOfDay: String
  currency: String
  pricePerUnit: Float @deprecated(reason: "Use rateExcludingTax instead.")
  bandCategory: String

  """Matches the Network Tariff Codes published by each LNSP."""
  networkTariffCode: String

  """Unit cost before tax."""
  rateExcludingTax: Float!

  """Unit cost including tax."""
  rateIncludingTax: Float!

  """Description for the network tariff code"""
  chargeDescription: String

  """Description that will show up on the customer's bill"""
  rateDescription: String
  validFrom: DateTime
  validTo: DateTime
}

"""Interface for Electricity and Gas rates"""
interface RateInterface {
  currency: String
  bandCategory: String

  """Unit cost before tax."""
  rateExcludingTax: Float!

  """Unit cost including tax."""
  rateIncludingTax: Float!

  """Description that will show up on the customer's bill"""
  rateDescription: String
  validFrom: DateTime
  validTo: DateTime

  """Start of the step the rate applies to."""
  stepStart: Float

  """End of the step the rate applies to (Exclusive)."""
  stepEnd: Float
}

"""An enumeration."""
enum MarketName {
  AUS_ELECTRICITY
  AUS_GAS
}

"""


This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type ElectricityMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ElectricityMeterReadingConnectionTypeEdge]!
}

"""
A Relay edge containing a `ElectricityMeterReadingConnectionType` and its cursor.
"""
type ElectricityMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ElectricityMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

union ElectricityMeterReadingType = ElectricityAccumulationMeterReadingType | ElectricityIntervalMeterReadingType

"""An electricity meter reading. Accumulated usage."""
type ElectricityAccumulationMeterReadingType implements MeterReading & AccumulationMeterReading {
  """"""
  qualityFlag: AccumulationReadingQualityFlag!
  qualityMethod: String

  """"""
  units: String!

  """"""
  value: Decimal!
  readAt: DateTime
  registers: [RegisterReading]
}

"""Interface for an AUS meter reading."""
interface MeterReading {
  registers: [RegisterReading]
}

type RegisterReading {
  identifier: String
  name: String
  value: String
  digits: Int
  isQuarantined: Boolean
  id: Int
  qualityFlag: QualityFlag

  """
  Acceptable values: 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 51, 52, 53, 54, 55, 56, 57, 58, 61, 62, 63, 64, 65, 66, 67, 68, 71, 72, 73, 74, 75, KI, KP, KE, KA
  """
  qualityMethod: String
}

"""An enumeration."""
enum QualityFlag {
  A
  E
  F
  N
  S
  V
}

"""Interface for an AUS accumulation meter reading."""
interface AccumulationMeterReading {
  registers: [RegisterReading]
  readAt: DateTime
}

"""An enumeration."""
enum AccumulationReadingQualityFlag {
  """Actual"""
  A

  """Estimated"""
  E

  """Final Substituted"""
  F

  """Null"""
  N

  """Substituted"""
  S

  """Variable"""
  V
}

"""An electricity meter reading. Usage within a time window."""
type ElectricityIntervalMeterReadingType implements MeterReading & IntervalMeterReading {
  startAt: DateTime
  endAt: DateTime
  registers: [RegisterReading]
}

"""Interface for an AUS interval meter reading."""
interface IntervalMeterReading {
  registers: [RegisterReading]
  startAt: DateTime
  endAt: DateTime
}

"""

Meter readings grouped by the date on which they occurred.

Interval readings which occur on the same date are summed.

Accumulation readings do not occur the same date.

"""
type DailyElectricityMeterReadingType {
  date: Date!
  registerId: String!
  value: Decimal!
}

"""
User objects are the core of the authentication system. They typically represent a customer who manages a portfolio of one or more accounts.
"""
type AccountUserType {
  """"""
  id: ID!
  accounts: [AccountInterface]

  """"""
  givenName: String!

  """"""
  familyName: String!

  """"""
  email: String!

  """"""
  mobile: String!

  """"""
  landline: String!

  """
  How this person wants us to refer to them in the third person, e.g. 'she/her', 'he/him', 'they/them'. Never guess this; leave it blank if not explicitly provided.
  """
  pronouns: String
  dateOfBirth: Date
  displayName: String @deprecated(reason: "Please use fullName instead of this field.")

  """We recommend you use preferredName or fullName instead of this field."""
  firstName: String @deprecated(reason: "Use 'givenName' instead")

  """We recommend you use preferredName or fullName instead of this field."""
  lastName: String @deprecated(reason: "Use 'familyName' instead")
  fullName: String
  preferredName: String
  portfolioId: ID
  specialCircumstances: SpecialCircumstancesType
  preferences: AccountUserCommsPreferences
  landlinePhoneNumber: String @deprecated(reason: "Use 'landline' instead.")
  alternativePhoneNumbers: [String]
  hasFamilyIssues: Boolean
  concessions: [ConcessionType]

  """
   Retrieve Masquerade token used for temporary user login to client sites 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  masqueradeToken: String
  primaryPlaceOfResidence: PrimaryResidenceType
}

interface AccountInterface {
  """The current status of the account"""
  status: AccountStatus

  """The current account balance."""
  balance: Int!

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  """
  
  **⚠️ This field is currently in preview. During this time,
  it may change without warning in backwards-incompatible
  ways.**
  
  The billing address of this account, stored in the new
  libaddressinput-based format.
  
  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  
  """
  address: RichAddressType

  """A code that uniquely identifies the account."""
  number: String

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers(
    """The ledger to return"""
    ledgerId: ID
  ): [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """The payments made into an account from a payment instruction."""
  payments(status: AccountPaymentStatusOptions, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean
    canCreatePayment: Boolean

    """The ledger to return transactions from."""
    ledgerType: Int
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType]

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """Number of referrals created by this account."""
  referralsCreated: Int

  """The rewards applied to this account."""
  rewards: [RewardType]

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs"""
    includeBillsWithoutPDF: Boolean = false

    """
    
    Include open statements. This flag needs to be used along with
    includeBillsWithoutPDF=false otherwise results will prove unexpected.
    
    """
    includeOpenStatements: Boolean = false

    """Only include bills emailed to the current user's email"""
    onlyCurrentEmail: Boolean = false
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The company type of a business account."""
  businessType: BusinessTypeOptions @deprecated(reason: "Use `business.businessType` instead")

  """Business info related to a business account."""
  business: BusinessType

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "Use `commsDeliveryPreference` instead")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]
}

enum AccountStatus {
  """
  A pending account is one that has been created but no registrations have started.
  """
  PENDING

  """Account requires processes to be completed before supply can be set up"""
  INCOMPLETE

  """Withdrawn before supply started"""
  WITHDRAWN

  """Supply could have started, be ongoing or ended."""
  ACTIVE

  """
  An error occurred when we tried to enroll a meter point. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_ERROR

  """
  Meter point enrollment was rejected. This may be deprecated in future in favour of exposing this through enrollment property of a meter point.
  """
  ENROLMENT_REJECTED

  """Dormant. Users should not be able to log into dormant accounts."""
  DORMANT
}

"""

**⚠️ This type is currently in preview. During this time, it
  may change without warning in backwards-incompatible
  ways.**

A postal address.

This data model is based on the structure used by Google's
[libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
you can use it, or other libraries that use its data model
and reference data, to accept input.

All fields can be blank, except for ``country`` which must
always be supplied.

"""
type RichAddressType {
  """A personal name."""
  name: String

  """The name of a business or organisation."""
  organization: String

  """
  
  The 'street address' component.
  
  This value can (and often will) contain newline characters
  when appropriate.
  
  In some cases, data may appear in this field instead of the
  below fields; e.g. a UK post town name may appear here
  instead of in the `dependent_locality` field. This happens
  when data has been migrated from a legacy format, and that
  format had insufficient metadata to determine the
  appropriate field.
  
  If `structured_street_address` is also set, the value of
  this field will be a string generated from that value.
  
  """
  streetAddress: String

  """
  
  The 'street address' component, in a structured format.
  
  This field stores the same value as `street_address`, but
  with more detail; for instance, instead of `123 Example
  Street` it might be `{'street_number': '123',
  'street_name': 'Example', 'street_type': 'Street'}`. In
  many cases this will be blank; we only use this field for
  Krakens where we need to supply this level of granularity
  to some third-party service, like a bulk mail provider.
  
  The exact structure of this value depends on the country _of
  the address_, which is not necessarily the same as the
  country this Kraken is configured to serve. For addresses
  outside of the countries listed below, this field will be
  left blank.
  
  ## `AU`: Australia
  
  The following keys may be present; all are optional. All
  keys have string values, and their meaning is the same as
  their aseXML counterparts. (Note that, unlike aseXML, all
  keys are provided at the top level, rather than being
  nested.)
  
  - `flat_or_unit_type`
  - `flat_or_unit_number`
  - `floor_or_level_type`
  - `floor_or_level_number`
  - `building_or_property_name`
  - `location_descriptor`
  - `house_number_1`
  - `house_number_suffix_1`
  - `house_number_2`
  - `house_number_suffix_2`
  - `lot_number`
  - `street_name`
  - `street_type`
  - `street_suffix`
  - `postal_delivery_type`
  - `postal_delivery_number_prefix`
  - `postal_delivery_number_value`
  - `postal_delivery_number_suffix`
  
  """
  structuredStreetAddress: GenericScalar

  """
  
  UK dependent localities, or neighbourhoods or boroughs in
  some other locations.
  
  """
  dependentLocality: String

  """
  
  City or town portion of an address, e.g. US city, AU
  suburb/town, IT comune, UK post town.
  
  """
  locality: String

  """
  
  Top-level administrative subdivision, e.g. US state, AU
  state/territory, IT region, JP prefecture.
  
  ## `AU`: Australia
  
  This must be one of `NSW`, `VIC`, `QLD`, `TAS`, `ACT`, `SA`,
  `NT`, `WA`. For addresses not within these locations, use
  the value that Australia Post uses, e.g. `ACT` for the
  Jervis Bay Territory or `WA` for Christmas Island.
  
  """
  administrativeArea: String

  """
  
  Postal code (ZIP code in the US).
  
  """
  postalCode: String

  """
  
  Sorting code, e.g. FR CEDEX code. This field is not used in many countries.
  
  """
  sortingCode: String

  """
  
  ISO 3166-1 alpha-2 code of the country this address belongs
  to, e.g. `AU`, `GB`.
  
  """
  country: String

  """
  
  Identifier used by the local postal service for this
  address, e.g. AU DPID, GB postcode + Delivery Point Suffix,
  US Zip-9 + Delivery Point.
  
  This is the value that gets encoded in the barcode printed
  on the envelope by large-volume bulk mail providers.
  
  """
  deliveryPointIdentifier: String
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type LedgerType implements LedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String

  """The ledger type code."""
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements(
    """The id of billing document"""
    statementId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): StatementBillingDocumentConnectionTypeConnection
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
}

interface LedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current balance on the ledger in minor units of currency."""
  balance: Int

  """Whether this ledger's balance contributes to the account's balance."""
  affectsAccountBalance: Boolean

  """
  A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
  """
  statements(before: String, after: String, first: Int, last: Int): StatementBillingDocumentConnectionTypeConnection
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [StatementBillingDocumentConnectionTypeEdge]!
}

"""
A Relay edge containing a `StatementBillingDocumentConnectionType` and its cursor.
"""
type StatementBillingDocumentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: StatementBillingDocumentType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A statement is a billing document that contains all entries on a ledger during a period of time. A customer can understand how their ledger's balance has changed by looking at each statement in series.
"""
type StatementBillingDocumentType {
  id: Int

  """The start of the statement's period."""
  startAt: DateTime!

  """The end of the statement's period."""
  endAt: DateTime!

  """URL to the PDF of the statement."""
  pdfUrl: String
}

type TransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TransactionConnectionTypeEdge]!
}

"""A Relay edge containing a `TransactionConnectionType` and its cursor."""
type TransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: TransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Transactions are a record of money being added or subtracted from the overall account balance
"""
interface TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in cents after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

"""

    Add here your filter type, e.g. MY_TYPE = "MY_TYPE". This type will come up as on option when applying a filter in
    the transactions() query in the GraphQL API.
    
"""
enum TransactionTypeFilter {
  """Return energy charge transactions: Gas or Electricity."""
  ENERGY_CHARGES
}

type AccountPaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountPaymentConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountPaymentConnectionType` and its cursor.
"""
type AccountPaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountPaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountPaymentType {
  """"""
  id: ID!

  """Amount of payment in pence"""
  amount: Int!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!

  """"""
  reference: String!

  """"""
  transactionType: String!

  """The current status of the payment"""
  status: AccountPaymentStatusOptions

  """Surchage amount generated by this payment."""
  surchargeAmount: Int
  schedulabilityStatus(
    """Days to extend the payment by"""
    numDays: Int!
  ): SchedulabilityStatusType
}

"""An enumeration."""
enum AccountPaymentStatusOptions {
  """
  The payment has been scheduled for collection and the customer has been notified. While a payment is scheduled, it can still be deleted.
  """
  SCHEDULED

  """The payment has been submitted. From this point it cannot be altered."""
  PENDING

  """
  The payment has been approved by the merchant and added to your Kraken account.
  """
  CLEARED

  """The payment failed permanently."""
  FAILED

  """
  A payment promise has been created, but it has not left the customers bank account.
  """
  PROMISED

  """
  The payment has been made successfully and applied to the Kraken balance.
  """
  FULFILLED

  """The payment promise has been broken."""
  PROMISE_BROKEN

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """
  The initial state of a payment in Kraken. It should be scheduled with a payment vendor in the future.
  """
  REQUESTED

  """This payment was deleted. From this point it cannot be altered."""
  DELETED
}

type SchedulabilityStatusType {
  description: String!
  canReschedule: Boolean!
}

type AccountRepaymentConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountRepaymentConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountRepaymentConnectionType` and its cursor.
"""
type AccountRepaymentConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountRepaymentType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountRepaymentType {
  """"""
  id: ID!

  """Amount of payment in pence"""
  amount: Int!

  """The date this payment is scheduled to be debited"""
  paymentDate: Date!

  """The current status of the repayment"""
  status: AccountRepaymentStatusOptions
}

"""An enumeration."""
enum AccountRepaymentStatusOptions {
  """The request for a repayment has been received but not actioned yet."""
  REQUESTED

  """The repayment has been approved but not made yet."""
  APPROVED

  """
  The payment has been submitted to the merchant. It is still possible for this repayment to fail.
  """
  SUBMITTED

  """
  The repayment failed permanently. This could be because of technical issues, or if the merchant rejects the payment for some reason. The payment will need to be retried by ops.
  """
  FAILED

  """
  The repayment has been made to the merchant to be sent to the customer. This is a terminal state, we don't get any further confirmation.
  """
  PAID

  """
  Third Party payments are those recorded for financial purposes in a different system but should be added to statements.
  """
  THIRD_PARTY

  """Payments made in a previous system and then imported into Kraken."""
  HISTORIC
}

type PaymentScheduleConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PaymentScheduleConnectionTypeEdge]!
}

"""
A Relay edge containing a `PaymentScheduleConnectionType` and its cursor.
"""
type PaymentScheduleConnectionTypeEdge {
  """The item at the end of the edge"""
  node: PaymentScheduleType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
An object that represents when we have agreed to take payments from a payment instruction.
"""
type PaymentScheduleType {
  """"""
  id: ID!

  """The supplementary ledger for this payment schedule, if it is on one"""
  supplementaryLedger: SupplementaryLedgerType

  """"""
  validFrom: Date!

  """"""
  validTo: Date

  """The reason the payment schedule was created."""
  reason: PaymentScheduleReasonOptions

  """"""
  paymentHolidayReason: String!

  """"""
  paymentDay: Int!

  """The frequency of the payment schedule"""
  paymentFrequency: PaymentFrequencyOptions

  """"""
  paymentFrequencyMultiplier: Int!

  """"""
  paymentAmount: Int!

  """"""
  paymentAdequacyAdjustment: Int

  """"""
  paymentAdequacyAdjustmentExpiryDate: Date

  """"""
  isVariablePaymentAmount: Boolean!

  """"""
  scheduleType: PaymentScheduleScheduleType!

  """
  The sum of the payment adequacy contributions on the payment schedule that are expected to be taken before the debt repayment is complete.
  """
  totalDebtAmount: Int
  isPaymentHoliday: Boolean
}

"""
Ledgers provide the foundation of Kraken’s bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular Kraken account.
"""
type SupplementaryLedgerType implements SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
}

interface SupplementaryLedgerInterface {
  id: ID

  """The display name of the ledger."""
  name: String
  ledgerType: String

  """The current final balance of the ledger in pence."""
  currentBalance: Int
}

"""An enumeration."""
enum PaymentScheduleReasonOptions {
  """The default value for usual account payments."""
  GENERAL_ACCOUNT_PAYMENT

  """
  A payment schedule created to take a payment around the supply start date of a meterpoint to help prevent accounts accruing debt.
  """
  SSD_PAYMENT

  """
  A payment schedule created to take the final payment when an account is closed.
  """
  FINAL_PAYMENT

  """
  A payment schedule created to take payments to pay back a debt. These schedules typically expire once the debt has been re-payed.
  """
  DEBT_REPAYMENT_PLAN
}

"""An enumeration."""
enum PaymentFrequencyOptions {
  """Weekly"""
  Weekly

  """Monthly"""
  Monthly
}

"""An enumeration."""
enum PaymentScheduleScheduleType {
  """Manual payment"""
  BACS_TRANSFER

  """Card payment"""
  CARD_PAYMENT

  """Direct debit"""
  DIRECT_DEBIT
}

type PaymentForecastType {
  paymentNumber: Int
  date: Date
  amount: Int
}

type ReferralConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ReferralConnectionTypeEdge]!
}

"""A Relay edge containing a `ReferralConnectionType` and its cursor."""
type ReferralConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ReferralType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Details of an account referral"""
type ReferralType implements ReferralInterface {
  """"""
  id: ID!
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  """Payment amount given to the referred account in cents."""
  referredUserPaymentAmount: Int

  """Payment amount given to the referring account in cents."""
  referringUserPaymentAmount: Int

  """
  The payment amount in cents received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

interface ReferralInterface {
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices
  referredUserName: String
  paymentStatus: String
  referredUserJoinDate: DateTime
  code: String

  """Payment amount given to the referred account in cents."""
  referredUserPaymentAmount: Int

  """Payment amount given to the referring account in cents."""
  referringUserPaymentAmount: Int

  """
  The payment amount in cents received by the referrer and the referee combined.
  """
  combinedPaymentAmount: Int
}

"""An enumeration."""
enum ReferralSchemeTypeChoices {
  """Referral Reward."""
  REFERRAL_REWARD

  """Signup Reward."""
  SIGNUP_REWARD

  """Partner Reward."""
  PARTNER_REWARD

  """Promo Reward."""
  PROMO_REWARD

  """Legacy Referral."""
  LEGACY_REFERRAL
}

"""

            A reward is based on a scheme that an account has applied for in order to be
            eligible for a discount. Examples can include signup, promo, or partner codes that
            were applied to an account.
            
"""
type RewardType implements RewardInterface {
  """"""
  id: ID!
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices

  """Reward amount given to the account in cents."""
  rewardAmount: Int

  """The status of the reward payment."""
  paymentStatus: ReferralStatusChoices
}

interface RewardInterface {
  paymentDate: Date

  """The type of reward scheme."""
  schemeType: ReferralSchemeTypeChoices

  """Reward amount given to the account in cents."""
  rewardAmount: Int

  """The status of the reward payment."""
  paymentStatus: ReferralStatusChoices
}

"""An enumeration."""
enum ReferralStatusChoices {
  """Pending."""
  Pending

  """Paid."""
  Paid

  """Cancelled."""
  Cancelled
}

type ReferralSchemeTypes {
  domestic: ReferralSchemeType
  business: ReferralSchemeType
  friendsAndFamily: ReferralSchemeType @deprecated(reason: "Please use domestic instead.")
}

"""
A referral scheme is a way for one account to earn a reward for referring another. This is achieved by the referred account using a url (provided by the referring account) to sign up.
"""
type ReferralSchemeType {
  """
  A fully qualified url give people to create accounts referred by this scheme.
  """
  referralUrl: String

  """A referral url for display purposes."""
  referralDisplayUrl: String

  """The reward amount received by the referrer."""
  referrerRewardAmount: Int

  """The reward amount received by the referred party."""
  referredRewardAmount: Int

  """The reward amount received by the referrer and the referee combined."""
  combinedRewardAmount: Int

  """
  Whether the current account is eligible to be referred under this scheme.
  """
  canBeReferred: Boolean

  """The unique code for the scheme."""
  code: String

  """The given name of the person making the referral."""
  referrerGivenName: String

  """The family name of the person making the referral."""
  referrerFamilyName: String
}

type ProvisionalTransactionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProvisionalTransactionConnectionTypeEdge]!
}

"""
A Relay edge containing a `ProvisionalTransactionConnectionType` and its cursor.
"""
type ProvisionalTransactionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: ProvisionalTransactionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
A provisional transaction represents some debit or credit to or from a customer's account which we cannot yet finalise for some reason, but which is still useful to keep a note of, and display to the customer. Provisional transactions are purely to give guidance in the absence of finalised information. We therefore only return provisional transactions that have not been finalised. When a transaction is finalised, it is available through the `transactions` field.
"""
type ProvisionalTransactionType {
  """"""
  id: ID!

  """
  A user readable string that indicates what this transaction relates to.
  """
  title: String

  """
  The amount in pence for this provisional transaction. It will be negative for charges, positive for credits.
  """
  amount: Int

  """The date at which the charge should be applied to the account."""
  date: Date
}

type AnnualStatementConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnualStatementConnectionTypeEdge]!
}

"""
A Relay edge containing a `AnnualStatementConnectionType` and its cursor.
"""
type AnnualStatementConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AnnualStatementType

  """A cursor for use in pagination"""
  cursor: String!
}

"""
Annual statements that are sent to the account. They summarize important information about usage and tariffs.
"""
type AnnualStatementType {
  """"""
  periodStartsAt: DateTime!

  """"""
  periodEndsAt: DateTime!
  id: ID
  pdfUrl: String
}

"""


This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type BillConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BillConnectionTypeEdge]!
}

"""A Relay edge containing a `BillConnectionType` and its cursor."""
type BillConnectionTypeEdge {
  """The item at the end of the edge"""
  node: BillInterface

  """A cursor for use in pagination"""
  cursor: String!
}

interface BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

enum BillTypeEnum {
  STATEMENT
  INVOICE
  CREDIT_NOTE
  PRE_KRAKEN
}

"""Information about an account's billing schedule."""
type BillingOptionsType {
  """
  The day of the month on which the account's billing period should start.
  """
  periodStartDay: Int

  """"""
  periodLength: AccountBillingOptionsPeriodLength

  """
  If true, this account is billed on specific day of a regular cycle. If false, the billing schedule is flexible, depending on when meter readings are submitted.
  """
  isFixed: Boolean!

  """The date on which the current billing cycle started."""
  currentBillingPeriodStartDate: Date

  """
  The date on which the current billing cycle will end. Null if the account is on flexible billing.
  """
  currentBillingPeriodEndDate: Date

  """
  The next date on which this account will next be billed. This is the same as the start date for their next bill cycle. Null if the account is on flexible billing.
  """
  nextBillingDate: Date
}

"""An enumeration."""
enum AccountBillingOptionsPeriodLength {
  """Monthly"""
  MONTHLY

  """Quarterly"""
  QUARTERLY
}

type DirectDebitInstructionConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DirectDebitInstructionConnectionTypeEdge]!
}

"""
A Relay edge containing a `DirectDebitInstructionConnectionType` and its cursor.
"""
type DirectDebitInstructionConnectionTypeEdge {
  """The item at the end of the edge"""
  node: DirectDebitInstructionType

  """A cursor for use in pagination"""
  cursor: String!
}

"""Direct Debit Instructions"""
type DirectDebitInstructionType {
  """"""
  id: ID!

  """"""
  status: String!

  """"""
  sortCode: String!

  """"""
  iban: String!

  """"""
  accountHolder: String!

  """"""
  instructionType: String

  """"""
  cardPaymentNetwork: String

  """"""
  cardExpiryMonth: Int

  """"""
  cardExpiryYear: Int

  """The last four digits of the account number."""
  lastFourDigitsOfAccountNumber: String @deprecated(reason: "Use 'masked_account_identifier' for a masked reference to the instruction. This field is misleading, as it's only the last 3 digits that are stored. We'll remove this field on 14/03/2020.")

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String

  """A masked version of the IBAN."""
  maskedIban: String
}

"""An enumeration."""
enum DirectDebitInstructionStatus {
  """The instruction is active and can be used to take payments."""
  ACTIVE

  """The instruction has not yet been set up."""
  PROVISIONAL

  """The instruction could not be set up with the vendor."""
  FAILED

  """The account for this instruction was closed."""
  ACCOUNT_CLOSED
}

type AccountEventConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountEventConnectionTypeEdge]!
}

"""A Relay edge containing a `AccountEventConnectionType` and its cursor."""
type AccountEventConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountEvent

  """A cursor for use in pagination"""
  cursor: String!
}

union AccountEvent = EmailEventType

type EmailEventType implements Node {
  """The ID of the object."""
  id: ID!

  """"""
  eventType: String!

  """"""
  occurredAt: DateTime!

  """
  Email message of the email event. Returns null for message's sent/received by other user's on the account
  """
  message: EmailType
}

"""An object with an ID"""
interface Node {
  """The ID of the object."""
  id: ID!
}

type EmailType {
  """"""
  id: ID!

  """"""
  sentAt: DateTime

  """Subject line of the email message."""
  subject: String

  """Attachments of the email message."""
  attachments: [EmailAttachmentType]
  textBody: String
  htmlBody: String

  """Email sender"""
  sender: String

  """Email recipient"""
  recipient: String
}

type EmailAttachmentType {
  """"""
  id: ID!

  """"""
  filename: String!

  """
  Temporary URL at which the email attachment is available. This URL will expire after approximately an hour. It is intended for redirection purposes, NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
  """
  temporaryUrl: String
}

"""An enumeration."""
enum AccountEventType {
  """The email messages that were sent by the account."""
  EMAIL_SENT

  """The email messages that were received by the account."""
  EMAIL_RECEIVED
}

type AccountApplicationConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AccountApplicationConnectionTypeEdge]!
}

"""
A Relay edge containing a `AccountApplicationConnectionType` and its cursor.
"""
type AccountApplicationConnectionTypeEdge {
  """The item at the end of the edge"""
  node: AccountApplicationType

  """A cursor for use in pagination"""
  cursor: String!
}

type AccountApplicationType {
  """"""
  status: AccountApplicationStatus!

  """"""
  salesChannel: String!

  """
  The sales subchannel used when signing up. This could for example be a price comparison site.
  """
  salesSubchannel: String

  """Date at which this account decided to switch to us."""
  dateOfSale: Date

  """
  Last day of the cooling off period. Barring changes or objections, the account will be gained on the next business day after this date. This value will only be returned for current applications.
  """
  coolingOffEndDate: Date

  """
  Whether this account application represents a migration into the current system or a regular gain.
  """
  isMigrated: Boolean

  """
  The source system for a migrated account. This could be the previous supplier or the previous account management system.
  """
  migrationSource: String
}

"""An enumeration."""
enum AccountApplicationStatus {
  """Current"""
  CURRENT

  """Failed"""
  FAILED

  """Historic"""
  HISTORIC
}

"""An enumeration."""
enum AccountTypeChoices {
  """An account designed to supply/bill business premises."""
  BUSINESS

  """An account designed to supply/bill domestic premises."""
  DOMESTIC

  """
  An account created when we supply a business premises but do not have details for the occupants.
  """
  BUSINESS_OCCUPIER

  """
  An account created when we supply a domestic premises but do not have details for the occupants.
  """
  OCCUPIER
}

"""An enumeration."""
enum BusinessTypeOptions {
  """A business account where the company type is sole trader."""
  SOLE_TRADER

  """A business account where the company type is limited."""
  LIMITED

  """A business account where the company type is partnership."""
  PARTNERSHIP

  """A business account where the company type is charity."""
  CHARITY

  """A business account where the company type is public limited."""
  PUBLIC_LIMITED_COMPANY

  """
  A business account where the company type is limited liability partnership.
  """
  LIMITED_LIABILITY_PARTNERSHIP

  """A business account where the company type is a trust."""
  TRUST

  """
  A business account where the company has a trading name to carry out its business activities.
  """
  TRADING_AS

  """A business account for a government institution."""
  GOVERNMENT

  """A business account for a non-profit organisation."""
  NON_PROFIT

  """A business account for a church or other religious organisation."""
  CHURCH
}

type BusinessType {
  """"""
  name: String!

  """"""
  number: String!

  """The company type of a business account."""
  businessType: BusinessTypeOptions
}

"""The method the account has specified they prefer we contact them"""
enum CommsDeliveryPreference {
  EMAIL
  POSTAL_MAIL
}

type AccountReferenceType {
  """"""
  account: AccountType!

  """
  The namespace for the reference will be one of the following strings: 
  
  origin.australia-post-client-reference-numbers
  
   origin.bpay-client-reference-numbers
  
   origin.broadband-client-account-numbers
  
   origin.centerpay-client-reference-numbers
  
   origin.centrepay-legacy-client-reference-numbers
  
   origin.fer-client-reference-numbers
  
   origin.eapa-client-reference-numbers
  
   origin.ivr-client-reference-numbers
  
   origin.heea-client-reference-numbers
  
   origin.spike-client-account-numbers
  
   origin.urgs-client-reference-numbers
  """
  namespace: String!

  """The unique identifier for the account."""
  value: String!

  """When this was created in our database."""
  createdAt: DateTime!

  """"""
  updatedAt: DateTime!
}

type AccountType implements AccountInterface {
  """A code that uniquely identifies the account."""
  number: String

  """The current status of the account"""
  status: AccountStatus

  """The current account balance."""
  balance: Int!

  """Unique reference number from a 3rd party enrolment."""
  urn: String

  """The billing name of the account."""
  billingName: String

  """The billing address of the account."""
  billingAddress: String
  billingAddressLine1: String
  billingAddressLine2: String
  billingAddressLine3: String
  billingAddressLine4: String
  billingAddressLine5: String
  billingAddressPostcode: String
  billingCountryCode: String
  billingDeliveryPointIdentifier: String

  """List of billing address lines."""
  splitBillingAddress: [String]

  """
  
  **⚠️ This field is currently in preview. During this time,
  it may change without warning in backwards-incompatible
  ways.**
  
  The billing address of this account, stored in the new
  libaddressinput-based format.
  
  Note that `name` and `organization` are very unlikely to be
  supplied here; the `billing_name` field on the account
  itself is generally used for that purpose instead.
  
  """
  address: RichAddressType

  """
  Ledgers provide the foundation of bookkeeping functionality. Similar to a bank account, they allow us to keep track of financial activity on a particular customer account.
  """
  ledgers(
    """The ledger to return"""
    ledgerId: ID
  ): [LedgerType]

  """Whether the account can request a credit refund."""
  canRequestRefund: Boolean

  """The payments made into an account from a payment instruction."""
  payments(status: AccountPaymentStatusOptions, before: String, after: String, first: Int, last: Int): AccountPaymentConnectionTypeConnection

  """The repayments that have been requested for this account."""
  repayments(
    """Only return repayments whose status matches one of these statuses"""
    statuses: [AccountRepaymentStatusOptions]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountRepaymentConnectionTypeConnection

  """
  The schedules that describe how we would expect to take payments for an account on a given month.
  """
  paymentSchedules(
    activeOnDate: Date
    active: Boolean
    canCreatePayment: Boolean

    """The ledger to return transactions from."""
    ledgerType: Int
    reason: PaymentScheduleReasonOptions
    before: String
    after: String
    first: Int
    last: Int
  ): PaymentScheduleConnectionTypeConnection

  """
  A list displaying the payment forecast for an account. The list starts from today's date (inclusive).
  """
  paymentForecast(
    """The end date to retrieve forecasts for. This end date is inclusive."""
    dateTo: Date!

    """
    The ledger to return payment forecasts from. Defaults to the main ledger when no ID is passed.
    """
    ledgerId: Int
  ): [PaymentForecastType]

  """The referrals created by this account."""
  referrals(before: String, after: String, first: Int, last: Int): ReferralConnectionTypeConnection

  """Number of referrals created by this account."""
  referralsCreated: Int

  """The rewards applied to this account."""
  rewards: [RewardType]

  """The referral schemes currently active for this account."""
  activeReferralSchemes: ReferralSchemeTypes

  """Fetch transactions that have taken place on the account."""
  transactions(
    """Return these transaction types only."""
    transactionTypes: [TransactionTypeFilter] = []

    """The ledger to return transactions from."""
    ledgerId: Int
    before: String
    after: String
    first: Int
    last: Int
  ): TransactionConnectionTypeConnection
  provisionalTransactions(before: String, after: String, first: Int, last: Int): ProvisionalTransactionConnectionTypeConnection

  """Fetch annual statements for the account."""
  annualStatements(before: String, after: String, first: Int, last: Int): AnnualStatementConnectionTypeConnection

  """Fetch issued bills (invoices/statements) for the account."""
  bills(
    """Include bills without PDFs"""
    includeBillsWithoutPDF: Boolean = false

    """
    
    Include open statements. This flag needs to be used along with
    includeBillsWithoutPDF=false otherwise results will prove unexpected.
    
    """
    includeOpenStatements: Boolean = false

    """Only include bills emailed to the current user's email"""
    onlyCurrentEmail: Boolean = false
    before: String
    after: String
    first: Int
    last: Int
  ): BillConnectionTypeConnection

  """Information about the account's billing cycle."""
  billingOptions: BillingOptionsType

  """Fetch a specific issued bill (invoice/statement) for the account."""
  bill(id: ID, billType: BillTypeEnum): BillInterface

  """The direct debit instructions of the account"""
  directDebitInstructions(
    """Filter the direct debit instructions by status"""
    statuses: [DirectDebitInstructionStatus]
    before: String
    after: String
    first: Int
    last: Int
  ): DirectDebitInstructionConnectionTypeConnection

  """The account events that were recorded for the account."""
  events(
    """Filter the account events by their type."""
    eventTypes: [AccountEventType]
    before: String
    after: String
    first: Int
    last: Int
  ): AccountEventConnectionTypeConnection

  """
  Applications by this account to become our customer. More recent applications will be listed first.
  """
  applications(before: String, after: String, first: Int, last: Int): AccountApplicationConnectionTypeConnection

  """The type of account."""
  accountType: AccountTypeChoices

  """The company type of a business account."""
  businessType: BusinessTypeOptions @deprecated(reason: "Use `business.businessType` instead")

  """Business info related to a business account."""
  business: BusinessType

  """The method the account has specified they prefer we contact them"""
  commsDeliveryPreference: CommsDeliveryPreference
  communicationDeliveryPreference: String @deprecated(reason: "Use `commsDeliveryPreference` instead")

  """Account references linked to this account."""
  references: [AccountReferenceType]

  """
  Files attached to this account. Only available if categories defined in settings.
  """
  fileAttachments: [AccountFileAttachment]

  """
  The maximum amount a customer is allowed to request as a refund and the reason why that's the maximum amount.
  """
  maximumRefund: MaximumRefundType

  """The campaigns associated with an account."""
  campaigns: [AccountCampaignType]
  electricityAgreements(active: Boolean): [ElectricityAgreementType] @deprecated(reason: "Use `agreements` instead.")
  agreements(active: Boolean): [AgreementInterface]
  properties(activeFrom: DateTime): [PropertyType]
  previousProperties: [PropertyType]

  """
  Fetch a list of due charges for an account.
  
  Due charges are defined for each issued statement as:
  
  ```
  Charges due = 0
  - Closing balance of the statement
  - Sum of payments and credits received after the statement's `to_date`
  - Due charges on previous statements
  ```
  
  (Remember that if the customer owes us money, then their balance will be negative, so
  subtracting it will result in a positive amount.)
  
  Usually, many of a customer's issued statements will have 0 due charges remaining. We omit
  most of these `0` results from the output.
  
  You may use `asOfDate` to request a historical view of due charges. If you set it, then
  statements issued after the `asOfDate` will be omitted, and payments and credits posted
  after that date will be ignored by the calculation.
  """
  dueCharges(asOfDate: Date = "2022-05-16"): [DueChargesType]

  """Information related to the viability of a payment extension"""
  paymentExtensionInfo: PaymentExtensionInfoType

  """
  
  **⚠️ This query is currently in preview. During this time, it
     may change without warning in backwards-incompatible
     ways.**
  
  Payment plan eligibility status of related account
  
  """
  paymentPlanEligibilityStatus: PaymentPlanEligibilityStatuses
}

type AccountFileAttachment implements Node & FileAttachment {
  """The ID of the object."""
  id: ID!

  """"""
  filename: String!

  """"""
  category: String!

  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

interface FileAttachment {
  """Is the file uploaded to S3?"""
  isUploaded: Boolean

  """Is the file ready for use / downloadable?"""
  isReady: Boolean
  fetchUrl: String
  sizeInBytes: Int
}

type MaximumRefundType {
  """The maximum amount available to be requested as a refund."""
  amount: Int

  """
  The reason why a specific amount is the maximum available to be requested as a refund.
  """
  reasonToRecommendAmount: MaximumRefundReasonChoices

  """
  The recommended minimum balance an account should have when asking for a refund.
  """
  recommendedBalance: Int
}

"""An enumeration."""
enum MaximumRefundReasonChoices {
  """
  Maximum refund is equal to the current balance minus the account recommended balance.
  """
  MAX_AVAILABLE_AMOUNT

  """
  Maximum refund is equal to the total amount the customer has paid using the current account Direct Debit instruction.
  """
  TOTAL_AMOUNT_PAID_VIA_ACTIVE_DDI

  """
  Maximum refund is equal to the maximum refund amount allowed to be requested via the dashboard.
  """
  MAX_ALLOWED_TO_REQUEST_VIA_DASHBOARD
}

type AccountCampaignType {
  """The name of the campaign."""
  name: String

  """The date that the campaign expires for the account."""
  expiryDate: Date
}

type ElectricityAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime

  """"""
  agreedAt: DateTime

  """"""
  terminatedAt: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
  product: Product
  supplyType: String
  isActive: String
  meterPoint: MeterPointType
}

"""
Note that this is electricity specific. Use `GasMeterPointType` for
gas meter points.
"""
type MeterPointType implements MeterPointInterface {
  id: Int
  meters(id: Int, includeInactive: Boolean): [ElectricityMeterType]

  """The Financial Responsible Market Participant status"""
  status: String @deprecated(reason: "Use `supply_status` instead.")

  """
  Details about an enrolment of this meter point. Will be null if no enrolment is taking place.
  """
  enrolment: EnrolmentType
  identifier: String

  """The Financial Responsible Market Participant status"""
  supplyStatus: KrakenStatus

  """
  A list of agreements belonging to an account that is linked to the logged in user.
  """
  agreements(includeInactive: Boolean = true): [AgreementInterface]

  """The fuel/service type for this meter point."""
  supplyType: String
  smartStartDate: Date
  lnsp: LNSPType!

  """The physical state of the meter point"""
  energizationStatus: EnergizationStatus
  supplyStartDate: Date
  roles: RoleType
  address: MeterPointAddressType
  customerClassification: String
  nmiClassification: String
  customerClassificationThreshold: String

  """
  
  MVP solution for calculating a predicted bill based on costed consumption
  and standing charges for a given meter point.
  
  The prediction is calculated by the following algorithm:
  
      P(A, B, C, D, E, F) = ( (A + ((B+C)/2)*D ) * E ) + F
  
  Where:
      A = Aggregated consumption for each register within this meter point
          in the billing period to date (kWh).
      B = 7 day average rolling window consumption per day (kWh).
      C = Average existing usage per day for the current billing period (kWh).
      D = Remaining days in the current billing period.
      E = Rate costs.
      F = Total standing charges for the billing period assuming the customer
          stays in the same current product rate.
  
  Exceptions:
      1. In the first day of the billing cycle, the variable C would tend
         towards zero. This would result in a poor result for the equation
         above. Instead, we replace the component ((B+C)/2)*D by B*D.
  
  Notes:
      1. The process of getting a meter reading and storing it usually takes
         about 24-48h in Kraken. This means that the prediction bill is
         always lagging 1 or 2 days behind.
         In order to circumvent this, concepts such as "usage to date" are
         translated as "usage until the date of the last reading" so that the
         calculation becomes more precise.
         In future, Kraken will start digesting and storing readings quicker,
         so that the date of the last reading will be today and the algorithm
         will catch up.
      2. Building a predicted bill can be computationally expensive
         so we've imposed a cache of 600 seconds
         on the query.
  
  This MVP Excludes:
    - Step tariffs.
    - accounts with flexible billing options.
    - Anything more or less granular than DAILY consumptions/standing charges.
    - Concessions.
    - Credits.
    - Rebates.
    - Seasonality.
  
  """
  predictedBill(
    """Include readings that have been quarantined in Kraken"""
    includeQuarantined: Boolean = false

    """Include estimated readings"""
    includeEstimates: Boolean = false

    """Include basic meters"""
    includeBasicMeters: Boolean = false
  ): PredictedBillType

  """
   
  Fetch standing charges on this meter point, bucketed into time
  slices of a variable granularity.
  
  The result will only include periods that are wholly between
  ``start_at`` and ``end_at``; so, for instance, if you have a
  ``start_at`` of midday and a ``granularity`` of ``DAILY``,
  you'll get results starting at midnight the following day.
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  standingChargesSummary(
    """
    
    Include data starting at this datetime.
    
    If a datetime-naïve value (without a UTC offset) is
    passed, this will be assumed to be in the timezone
    specified in ``timezone``
    
    """
    startAt: DateTime!

    """
    
    Include data ending at this datetime.
    
    If a datetime-naïve value (without a UTC offset) is passed,
    this will be assumed to be in the timezone specified in
    ``timezone``
    
    """
    endAt: DateTime!

    """
    Olson timezone identifier to use (e.g. `Australia/Melbourne`). This is used to determine what time of day to split days and months.
    """
    timezone: String!

    """How granular the returned results should be"""
    granularity: ConsumptionGranularity!
  ): [SummarizedConsumptionType!]!
}

"""
An electricity meter is a collection of registers which store readings. Eco7 meters are an example of a meter with multiple registers (for day and night).
"""
type ElectricityMeterType implements Meter {
  id: ID!

  """"""
  meterPoint: MeterPointType!

  """"""
  activeFrom: DateTime

  """"""
  activeTo: DateTime
  serialNumber: String!

  """"""
  status: MeterStatus!

  """"""
  installationType: MeterInstallationType!

  """"""
  nextScheduledReadDate: Date

  """"""
  readTypeMethod: MeterReadTypeMethod

  """"""
  readTypeMode: MeterReadTypeMode

  """"""
  readTypeFrequency: MeterReadTypeFrequency

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
  readings(includeQuarantined: Boolean = false, before: String, after: String, first: Int, last: Int): ElectricityMeterReadingConnectionTypeConnection
  registers: [ElectricityRegisterType]
}

"""An enumeration."""
enum MeterStatus {
  """Current"""
  C

  """Removed"""
  R

  """Remotely Disconnected"""
  D
}

"""An enumeration."""
enum MeterInstallationType {
  """BASIC"""
  BASIC

  """COMMS1"""
  COMMS1

  """COMMS2"""
  COMMS2

  """COMMS3"""
  COMMS3

  """COMMS4"""
  COMMS4

  """Comms4A"""
  COMMS4A

  """COMMS4C"""
  COMMS4C

  """COMMS4D"""
  COMMS4D

  """MRAM"""
  MRAM

  """MRIM"""
  MRIM

  """NCONUML"""
  NCONUML

  """PROF"""
  PROF

  """SAMPLE"""
  SAMPLE

  """UMCP"""
  UMCP

  """VICAMI"""
  VICAMI
}

"""An enumeration."""
enum MeterReadTypeMethod {
  """Manual"""
  M

  """Remote"""
  R
}

"""An enumeration."""
enum MeterReadTypeMode {
  """Telephone"""
  T

  """Wireless"""
  W

  """Powerline"""
  P

  """Infra Red"""
  I

  """Galvanic"""
  G

  """Visual"""
  V
}

"""An enumeration."""
enum MeterReadTypeFrequency {
  """Monthly"""
  A_1

  """Bi Monthly"""
  A_2

  """Quarterly"""
  A_3

  """Daily Or Weekly"""
  D
}

"""
A register on a meter.See _standing data for MSATS_ for more information.
"""
type ElectricityRegisterType {
  """"""
  id: ID!
  dataStream: ElectricityDataStreamType!

  """MSATS RegisterId."""
  identifier: String!

  """
  Code to identify the time validity of register contents, as published by each LNSP.
  """
  timeOfDay: String!

  """"""
  status: RegisterStatus!

  """"""
  activeFrom: DateTime

  """From the Network Tariff Codes supplied and published by each LNSP."""
  networkTariffCode: String!

  """"""
  dialFormatDigits: Int

  """"""
  dialFormatDecimals: Int

  """"""
  suffix: String
  unitOfMeasure: UnitOfMeasure!
  isExportRegister: Boolean!
  isActive: Boolean!

  """Whether the register measures reactive power"""
  isReactive: Boolean!

  """
   
  Fetch summaries of electricity meter readings.
  You need to pass in the readings granularity desired for the results (e.g. DAILY or MONTHLY).
  Optionally include readings that have been quarantined (these are excluded by default).
  Also optionally include/exclude estimated readings (included by default).
  Days where no meter readings occurred will be omitted.
  
  The summarised readings returned have the same semantic meaning as
  raw readings for this register; interval meters will return a
  consumption figure for this interval, and accumulation
  meters will return a raw read (that must be subtracted from
  the previous read to determine consumption).
  
  If this isn't what you want, use `consumptionSummary`
  instead.
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  readingsSummary(
    """Readings which happened before the start of this day will be excluded."""
    startDate: Date!

    """Readings which happened after the end of this day will be excluded."""
    endDate: Date!

    """Data granularity desired for the summary results"""
    readingsGranularity: ReadingsGranularity!

    """Include readings that have been quarantined in Kraken"""
    includeQuarantined: Boolean = false

    """Include estimated readings"""
    includeEstimates: Boolean = true
  ): [DailyElectricityMeterReadingType]

  """
   
  Fetch consumption on this register, bucketed into time
  slices of a variable granularity.
  
  Unlike `readingsSummary`, this endpoint returns
  _consumption_; in particular, for accumulation meters, the
  returned value represents the absolute amount of energy
  consumed, rather than reading values.
  
  When the readings we have are less granular than the
  requested granularity (e.g. half-hourly or even monthly
  consumption requested on an interval meter), the consumption
  is divided evenly.
  
  Note that, because the way that humans measure time is
  weird, so too are the results of this endpoint. For
  instance, a day may not have exactly 48 half-hour periods
  (because a DST transition happened), and a three-month
  interval of meter readings may not appear to be spread
  evenly between months (because months have different numbers
  of days).
  
  The result will only include periods that are wholly between
  ``start_at`` and ``end_at``; so, for instance, if you have a
  ``start_at`` of midday and a ``granularity`` of ``DAILY``,
  you'll get results starting at midnight the following day.
   
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  consumptionSummary(
    """
    
    Include data starting at this datetime.
    
    If a datetime-naïve value (without a UTC offset) is
    passed, this will be assumed to be in the timezone
    specified in ``timezone``; if the UTC offset is absent
    and it is a time that occurs more than once in the given
    timezone (e.g. 2am on a transition out of DST) the
    behaviour is undefined.
    
    """
    startAt: DateTime!

    """
    
    Include data ending at this datetime. If a
    datetime-naïve value (without a UTC offset) is passed,
    this will be assumed to be in the timezone specified in
    ``timezone``; if the UTC offset is absent and it is a
    time that occurs more than once in the given timezone
    (e.g. 2am on a transition out of DST) the behaviour
    is undefined.
    
    """
    endAt: DateTime!

    """
    Olson timezone identifier to use (e.g. `Australia/Melbourne`). This is used to determine what time of day to split days and months.
    """
    timezone: String!

    """How granular the returned results should be"""
    granularity: ConsumptionGranularity!

    """Include readings that have been quarantined in Kraken"""
    includeQuarantined: Boolean = false

    """Include estimated readings"""
    includeEstimates: Boolean = true
  ): [SummarizedConsumptionType!]!
}

"""A data stream for one or more meter registers."""
type ElectricityDataStreamType {
  """Estimated energy used by the data stream for this register (kWh/day)."""
  averageDailyLoad: Float!
}

"""An enumeration."""
enum RegisterStatus {
  """Current"""
  C

  """Removed"""
  R
}

"""An enumeration."""
enum UnitOfMeasure {
  """MWh"""
  MWH

  """kWh"""
  KWH

  """Wh"""
  WH

  """MVArh"""
  MVARH

  """kVArh"""
  KVARH

  """VArh"""
  VARH

  """MVAr"""
  MVAR

  """kVAr"""
  KVAR

  """VAr"""
  VAR

  """MW"""
  MW

  """kW"""
  KW

  """W"""
  W

  """MVAh"""
  MVAH

  """kVAh"""
  KVAH

  """VAh"""
  VAH

  """MVA"""
  MVA

  """kVA"""
  KVA

  """VA"""
  VA

  """kV"""
  KV

  """V"""
  V

  """kA"""
  KA

  """A"""
  A

  """pf"""
  PF
}

"""An enumeration."""
enum ReadingsGranularity {
  DAILY
  MONTHLY
}

type SummarizedConsumptionType {
  startAt: DateTime!
  endAt: DateTime!
  consumption: Float!

  """
  
  The cost of this consumption, in Australian cents.
  
  Note that this value is **approximate**, and only takes into
  account the rate at which consumption is charged. It does not
  include supply charges, pay-on-time discounts, concessions,
  card fees, or anything else of the sort.
  
  It may also be absent, if the rate at which consumption was
  (or will be) charged isn't known to Kraken at the time.
  
  """
  cost: Float

  """
  
  The same value as the `cost` field but with GST included.
  
  """
  costWithGst: Float
}

"""An enumeration."""
enum ConsumptionGranularity {
  HALF_HOURLY
  DAILY
  MONTHLY
}

type LNSPType {
  id: String!
  shortName: String!
  longName: String!
  displayName: String!
  emergencyPhoneNumber: String!
  outagePhoneNumber: String
}

"""An enumeration."""
enum EnergizationStatus {
  A
  D
  X
  G
  N
}

type RoleType {
  frmp: String
  lnsp: String
  mc: String
  mdp: String
  mpb: String
}

type MeterPointAddressType {
  dpid: Int
  buildingName: String
  flatNumber: String
  flatType: String
  floorNumber: String
  floorType: String
  houseNumber: Int
  houseNumberSuffix: String
  locationDescriptor: String
  lotNumber: String
  streetName: String
  streetSuffix: String
  streetType: String
  locality: String
  state: String
  postcode: String
}

type PredictedBillType {
  costInCents: Decimal
  costInCentsWithGst: Decimal
  lastReadingDatetime: DateTime
  billStartsAt: DateTime
  billEndsAt: DateTime
  lastReading: ElectricityMeterReadingType

  """Components used to calculate the prediction equation."""
  components: PredictedBillComponentsType
  predictedBillError: PredictedBillErrorUnion

  """Additional metrics calculated from the predicted bill."""
  metrics: PredictedBillMetricsType
}

type PredictedBillComponentsType {
  """Consumption charges since the beginning of the current billing period."""
  consumptionChargesToDate: PredictedBillChargeType!

  """
  Consumption charges predicted from now until the end of the current billing period.
  """
  predictedConsumptionCharges: PredictedBillChargeType!
  pastWeekConsumptionCharges: PredictedBillChargeType!

  """Standing charges since the beginning of the current billing period."""
  standingChargesToDate: PredictedBillChargeType!

  """
  Standing charges predicted from now until the end of the current billing period.
  """
  predictedStandingCharges: PredictedBillChargeType!
  secondsUntilEndOfBillingPeriod: Int!
  secondsSinceBeginningOfBillingPeriod: Int!
}

type PredictedBillChargeType {
  costInCents: Decimal!
  costInCentsWithGst: Decimal!
}

union PredictedBillErrorUnion = PredictedBillBasicMeterNotSupportedErrorType | PredictedBillFailedToDeterminePeriodErrorType | PredictedBillFixedBillingNotSupportedErrorType | PredictedBillTenantNotFoundErrorType | PredictedBillReadingNotFoundErrorType | PredictedBillBasicMetersRequiredOnQuarantineType

type PredictedBillBasicMeterNotSupportedErrorType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillFailedToDeterminePeriodErrorType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillFixedBillingNotSupportedErrorType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillTenantNotFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillReadingNotFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillBasicMetersRequiredOnQuarantineType implements GenericErrorInterfaceType {
  message: String!
}

type PredictedBillMetricsType {
  """
  
  Average daily charges considering the whole billing period.
  If a nullable is returned, the billing options haven't been set
  properly and might require an Energy Specialist to fix it.
  
  """
  averageDailyChargesPredicted: PredictedBillChargeType

  """
  
  Average daily charges from the beginning of the billing period to
  date. Where 'to date' currently refers to the date of the last
  reading.
  If a nullable is returned, not enough days (less than one) have
  accrued since the beginning of the billing period. Therefore
  the *daily* average cost can't be calculated yet.
  
  """
  averageDailyChargesToDate: PredictedBillChargeType
}

type PropertyType implements PropertyInterface {
  id: String

  """"""
  addressLine1: String!

  """"""
  addressLine2: String!

  """"""
  addressLine3: String!

  """"""
  addressLine4: String!

  """"""
  addressLine5: String!

  """"""
  postcode: String!

  """The address of the property, formatted into a single string"""
  address: String

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """Measurements at a property"""
  measurements(
    """Earliest date/time to return measurements from."""
    startAt: DateTime

    """Latest date/time to return measurements to (exclusive)."""
    endAt: DateTime

    """Earliest date to return measurements from."""
    startOn: Date

    """Latest date to return measurements for (inclusive)."""
    endOn: Date

    """Timezone to use for grouping. Defaults to Kraken localtime."""
    timezone: String

    """
    List of prefixes to filter against sources. Empty implies no filtering.
    """
    only: [String!]
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection
  electricityMeterPoints: [MeterPointType] @deprecated(reason: "Use `meter_points` instead.")
  meterPoints: [MeterPointInterface]

  """
  Estimated daily energy usage for households of different
  sizes in this property's neighbourhood (selected by
  postcode) for the season which overlaps the current
  billing period.
  
  If the property isn't on supply, or isn't on a fixed
  billing schedule, then we will return the benchmarks which
  would apply today instead.
  
  Returns null if we don't have benchmark data for this
  combination of postcode and season.
  """
  benchmarks: [EnergyBenchmarkType]
}

interface PropertyInterface {
  id: String

  """The address of the property, formatted into a single string"""
  address: String

  """List of address lines."""
  splitAddress: [String]

  """
  Time periods during which the property is associated with an account. Useful to display information about house-moves, as performing a move out of a property will set the end date for the occupancy period.
  """
  occupancyPeriods: [OccupancyPeriodType]

  """
  Coordinates for the property, useful for displaying the property on a map.
  """
  coordinates: CoordinatesType

  """Measurements at a property"""
  measurements(
    """Earliest date/time to return measurements from."""
    startAt: DateTime

    """Latest date/time to return measurements to (exclusive)."""
    endAt: DateTime

    """Earliest date to return measurements from."""
    startOn: Date

    """Latest date to return measurements for (inclusive)."""
    endOn: Date

    """Timezone to use for grouping. Defaults to Kraken localtime."""
    timezone: String

    """
    List of prefixes to filter against sources. Empty implies no filtering.
    """
    only: [String!]
    before: String
    after: String
    first: Int
    last: Int
  ): MeasurementConnection
}

"""An occupancy period for a property."""
type OccupancyPeriodType {
  id: ID
  effectiveFrom: DateTime
  effectiveTo: DateTime
}

type CoordinatesType {
  latitude: Float
  longitude: Float
}

"""Pagination for measurements."""
type MeasurementConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MeasurementEdge]!
}

"""A Relay edge containing a `Measurement` and its cursor."""
type MeasurementEdge {
  """The item at the end of the edge"""
  node: MeasurementInterface

  """A cursor for use in pagination"""
  cursor: String!
}

interface MeasurementInterface {
  source: String!
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

"""Estimated daily energy usage for a household in kWh/day."""
scalar EnergyBenchmarkType

type DueChargesType {
  """Number of cents that the customer still needs to pay."""
  amount: Int!

  """The statement that contained these charges."""
  statement: StatementType!

  """Date that the customer is expected to pay by."""
  dueDate: Date!
}

type StatementType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date

  """This field returns the closing balance of an issued statement."""
  closingBalance: Int

  """Whether the bill originated in Kraken or externally."""
  isExternalBill: Boolean

  """Transactions on the bill."""
  transactions(before: String, after: String, first: Int, last: Int): TransactionConnectionTypeConnection

  """Email recipient user ID."""
  userId: Int

  """Email recipient address."""
  toAddress: String

  """The date the bill is due to be paid."""
  paymentDueDate: Date

  """The first day of consumption that this statement includes"""
  consumptionStartDate: Date

  """The last day of consumption that this statement includes"""
  consumptionEndDate: Date

  """How many charges have been reversed after the close date."""
  reversalsAfterClose: StatementReversalsAfterClose!

  """
  This field returns the average daily usage during the time period of an issued statement.
  """
  averageDailyUsage: Float

  """Whether the statement is a final energy statement."""
  isFinal: Boolean
}

"""An enumeration."""
enum StatementReversalsAfterClose {
  """All charges have been reversed after the statement was closed."""
  ALL

  """Some charges have been reversed after the statement was closed."""
  SOME

  """No reversals after the statement was closed."""
  NONE

  """The statement has not been closed yet."""
  NOT_CLOSED
}

type PaymentExtensionInfoType {
  """Options for setting up a payment extension"""
  paymentExtensionOptions: PaymentExtensionOptionsType

  """Payment extension eligibility information"""
  paymentExtensionEligibility: PaymentExtensionEligibilityType
}

type PaymentExtensionOptionsType {
  """The allowable dates on which a full payment can be made"""
  payInFull: [Date]!

  """The allowable start dates on which a weekly payment can be initiated"""
  weekly: [Date]!

  """
  The allowable start dates on which a fortnightly payment can be initiated
  """
  fortnightly: [Date]!

  """The full amount that is due on the customer account"""
  fullAmount: Int!

  """The instalment amount for the regular payments"""
  instalmentAmount: Int!
}

type PaymentExtensionEligibilityType {
  """Is the customer eligible for payment extension"""
  isEligibleForPaymentExtension: Boolean
  requestedAt: RequestedAt

  """Is the customer's billing address in Victoria or not"""
  isInVictoria: Boolean
}

"""When is the payment extension requested"""
enum RequestedAt {
  AFTER_DUE_DATE
  BEFORE_DUE_DATE
}

"""An enumeration."""
enum PaymentPlanEligibilityStatuses {
  """Account Is On Hardship Agreement."""
  ACCOUNT_IS_ON_HARDSHIP_AGREEMENT

  """Account Has Negative Balance."""
  ACCOUNT_HAS_NEGATIVE_BALANCE

  """Account Has Fixed Debt Repayment Schedule."""
  ACCOUNT_HAS_FIXED_DEBT_REPAYMENT_SCHEDULE

  """Account Can Have Payment Plan."""
  ACCOUNT_CAN_HAVE_PAYMENT_PLAN
}

"""Information about the special circumstances that relate to a user."""
type SpecialCircumstancesType {
  """
  Whether the user has consented for their data to be given to the appropriate industry or regulatory bodies. We typically only ask for this once, so this field can be used to decide whether to ask the user for their initial consent.
  """
  isSharingConsentGiven: Boolean
  records: [SpecialCircumstanceRecordUnion]
}

union SpecialCircumstanceRecordUnion = SpecialCircumstanceRecordType | TemporarySpecialCircumstanceRecordType

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services.
"""
type SpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
}

"""
Any special circumstances that the user has notified us about, which may entitle them to some specialist services. These circumstances have an end date,after which they will not longer apply. Having young children is an example of thisin the UK.
"""
type TemporarySpecialCircumstanceRecordType {
  id: ID
  summary: String
  internalCode: String
  expiryDate: Date
}

"""Information about the preferences set up for a user."""
type AccountUserCommsPreferences {
  """
  Whether a user has opted in to receive messages from the client or client group. For example, for Octopus Energy this describes whether a user is opted in to offers from Octopus Investments.
  """
  isOptedInToClientMessages: Boolean

  """
  Whether a user has opted in to receive messages offering discounts or other servicesnot directly related to the services the client provides.
  """
  isOptedInToOfferMessages: Boolean

  """
  Whether a user has opted in to receive messages we recommend they read, but are not vital to the utilities the client provides. For example, these could be reminders that the client will take a payment.
  """
  isOptedInToRecommendedMessages: Boolean

  """
  Whether a user has opted in to receive messages updating them on client activities.
  """
  isOptedInToUpdateMessages: Boolean

  """
  Whether a user has opted in to receive messages from the client's preferred third parties.
  """
  isOptedInToThirdPartyMessages: Boolean

  """What format the user would like to receive their emails in."""
  emailFormat: EmailFormats

  """
  Whether a user has opted to have inverted colours in their emails. This is currently only relevant to the Octopus Energy brand, whose emails have a dark background by default.
  """
  isUsingInvertedEmailColours: Boolean

  """
  This setting allows the user to adjust the default font size of the communications sent to them.
  """
  fontSizeMultiplier: Float

  """
  Whether the user has opted in to receive meter reading confirmation emails.
  """
  isOptedInMeterReadingConfirmations: Boolean

  """Whether the user has opted in to receive SMS messages."""
  isOptedInToSmsMessages: Boolean

  """Song which will be used as hold music for the user."""
  preferredHoldMusic: Songs
}

"""An enumeration."""
enum EmailFormats {
  """Plain text emails."""
  TEXT

  """Full featured HTML emails with images and branding."""
  HTML
}

"""An enumeration."""
enum Songs {
  """No Song Preferred"""
  NO_SONG_PREFERRED
}

type ConcessionType {
  """"""
  id: ID!

  """"""
  number: String

  """"""
  cardIssueDate: Date

  """"""
  cardExpiryDate: Date

  """"""
  isCurrent: Boolean

  """"""
  removalDate: Date
  applicablePeriods: [ConcessionCardApplicablePeriodType]
  cardType: ConcessionCardType
  concessionValidations: [ConcessionCardValidationType]
  isCardValid: Boolean
}

type ConcessionCardApplicablePeriodType {
  """"""
  id: ID!

  """"""
  fromDate: Date!

  """"""
  toDate: Date
}

"""An enumeration."""
enum ConcessionCardType {
  """Centrelink - Pensioner"""
  CENTRELINK_PENSIONER

  """Centrelink - Health Care"""
  CENTRELINK_HEALTH_CARE

  """Veterans Affairs - Pensioner"""
  VETERANS_AFFAIRS_PENSIONER

  """Veterans Affairs - DVA Gold"""
  VETERANS_AFFAIRS_DVA_GOLD

  """Veterans Affairs - DVA Gold - WW"""
  VETERANS_AFFAIRS_DVA_GOLD_WW

  """Veterans Affairs - DVA Gold - TPI"""
  VETERANS_AFFAIRS_DVA_GOLD_TPI

  """Veterans Affairs - DVA Gold - EDA"""
  VETERANS_AFFAIRS_DVA_GOLD_EDA

  """Queensland Seniors Card"""
  QUEENSLAND_SENIORS_CARD

  """Asylum Seeker"""
  ASYLUM_SEEKER

  """Other - (no concessions apply)"""
  OTHER

  """South Australia Concession"""
  SA_GENERIC

  """Repatriation Health Care Card"""
  REPATRIATION_HEALTH_CARE_CARD

  """ACT Services Access Card/ Immi Card"""
  ACT_SERVICES_ACCESS_CARD_IMMI_CARD
}

type ConcessionCardValidationType {
  """"""
  id: ID!

  """"""
  validatedAt: Date!

  """"""
  isCardValid: Boolean!

  """"""
  validationDt: DateTime

  """"""
  method: ConcessionCardValidationMethod

  """"""
  failureCode: String

  """"""
  failureReason: String

  """"""
  notes: String
}

"""An enumeration."""
enum ConcessionCardValidationMethod {
  """API"""
  API

  """Batch"""
  BATCH

  """Manual"""
  MANUAL

  """Kraken"""
  KRAKEN
}

type PrimaryResidenceType {
  """"""
  id: ID!
  user: AccountUserType
  property: PropertyType

  """Inclusive, industrytime"""
  fromDate: Date!

  """Exclusive, industrytime"""
  toDate: Date

  """"""
  updatedAt: DateTime
}

input AccountUserSearchInputType {
  givenName: String!
  familyName: String!
  dateOfBirth: Date!
  email: String!
  mobile: String!
  landline: String!

  """
  
  field for settings the confidence score of results,
  useful when we have multiple account users with similar
  matching fields.
  Set between:
   - Float(0.0) (Match everything)
   - Float(1.0) (Match nothing)
  
  """
  threshold: Float = 0.55

  """
  
  Allows optional extra weighting on search fields.
  Boost certain fields between Float(0.0) and Float(1.0)
  to increase prominence of that field in the total search
  result calculation
  
  """
  searchWeightMappings: AccountUserFuzzySearchWeightMappingType
}

input AccountUserFuzzySearchWeightMappingType {
  givenName: Float = 0.147
  familyName: Float = 0.104
  dateOfBirth: Float = 0.153
  email: Float = 0.209
  mobile: Float = 0.228
  landline: Float = 0.083
}

"""Affiliate link for the organization."""
type AffiliateLinkType {
  """"""
  id: ID!
  organisation: AffiliateOrganisationType

  """"""
  subdomain: String!

  """"""
  trainingStatus: LinkTrainingStatus!

  """"""
  isBusiness: Boolean!

  """"""
  contactName: String!

  """"""
  contactEmail: String!

  """"""
  landingUrl: String!
}

type AffiliateOrganisationType {
  """"""
  id: ID!

  """"""
  name: String!

  """Sales Channel"""
  salesChannel: SalesChannelChoices

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""An enumeration."""
enum SalesChannelChoices {
  DIRECT
  PRICE_COMPARISON
  TELESALES
  DIGI_TELESALES
  EVENTS
  FIELD_SALES
  AGGREGATOR
  PARTNERSHIPS
  NEW_TENANT
  MOVE_IN
  WORKPLACE_POP_UP
  BROKER
  PARENT_POWER
  PEOPLE_POWER
  GIFT_OF_KIT
  HIGH_REFERRER
  SUPPLIER_OF_LAST_RESORT
  ACQUISITION
  WORKS_WITH_OCTOPUS
  LANDLORD
}

"""An enumeration."""
enum LinkTrainingStatus {
  """Not applicable"""
  NOT_APPLICABLE

  """In training"""
  IN_TRAINING

  """Qualified"""
  QUALIFIED
}

type TermsAndConditionsType {
  name: String
  pdfUrl: String
  brandCode: String

  """The markdown text of the terms and conditions."""
  markdown: String

  """
  The html of the terms and conditions document rendered as a JSON string.
  """
  html: String
  version: String
  effectiveFrom: DateTime
}

type DepositAgreementOutput {
  depositKey: String
  depositAmount: Int
  acceptedAt: DateTime
  fulfilledAt: DateTime
}

"""Payment Instructions"""
type PaymentInstructionType {
  """"""
  id: ID!

  """"""
  status: String!

  """"""
  sortCode: String!

  """"""
  iban: String!

  """"""
  accountHolder: String!

  """"""
  instructionType: String

  """"""
  cardPaymentNetwork: String

  """"""
  cardExpiryMonth: Int

  """"""
  cardExpiryYear: Int

  """"""
  bankCode: String

  """"""
  accountType: String

  """"""
  validFrom: DateTime!

  """
  The provider to use for this DDI. Most accounts would have SmartDebit as their provider, Iresa customers use GoCardless
  """
  vendor: String!

  """"""
  cardNumber: String!

  """"""
  cardType: String

  """A masked reference to a recurring payment method."""
  maskedAccountIdentifier: String
}

"""An enumeration."""
enum PaymentType {
  DIRECT_DEBIT
  CARD
}

type Metadata {
  """The key for the metadata."""
  key: String!

  """The metadata value."""
  value: JSONString
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

enum LinkedObjectType {
  ACCOUNT
  ACCOUNT_USER
}

"""
This class inherits from multiple Mutations as we add more apps to the API.
"""
type Mutation {
  """
  Mutation to create an electricity quote for a different nmi for a related account.
  """
  createElectricityQuote(input: CreateElectricityQuoteInput!): CreateElectricityQuote

  """Mutation to create a gas quote for a property."""
  createGasQuote(input: CreateGasQuoteInput!): CreateGasQuote

  """
  Update an existing credit card instruction
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  """
  updateCreditCardInstruction(
    """Input fields for updating a credit card instruction"""
    input: UpdateCreditCardInstructionInput!
  ): UpdateCreditCardInstruction

  """
  Create new direct debit instruction
  
  Expected `errorClass`:
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createDirectDebitInstruction(
    """Input fields for creating a new direct debit instruction"""
    input: CreateDirectDebitInstructionInput!
  ): CreateDirectDebitInstruction

  """
  Replaced the active payment schedule with a manual payment schedule.
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  replacePaymentSchedule(
    """Input fields for replacing the active payment schedule"""
    input: ReplacePaymentScheduleInput!
  ): ReplacePaymentSchedule

  """
  Create a new credit card instruction
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createCreditCardInstruction(
    """Input fields for creating a credit card instruction."""
    input: CreateCreditCardInstructionInput!
  ): CreateCreditCardInstruction

  """
  Creates a new payment schedule
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createPaymentSchedule(input: PaymentScheduleInput!): CreatePaymentSchedule

  """
  Deletes an existing payment instruction
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  deletePaymentInstruction(
    """Input fields for deleting a payment instruction"""
    input: DeletePaymentInstructionInput!
  ): DeletePaymentInstruction

  """
  Make Payment with a new card and save the card
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  makePaymentWithNewCard(
    """Input fields for making a payment with a new card"""
    input: MakePaymentWithNewCardInput!
  ): MakePaymentWithNewCard

  """
  Make a payment with a saved credit card instruction.
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  makePaymentWithSavedCard(
    """Input fields for making a payment with a saved card"""
    input: MakePaymentWithSavedCardInput!
  ): MakePaymentWithSavedCard

  """
  Setup the payment schedules and payment instructions, usually after a product switch.
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  setupPaymentDetails(
    """Input fields for setting up the payment details on the account"""
    input: SetupPaymentDetailsInput!
  ): SetupPaymentDetails

  """
  
  Creates payment extension according to the recieved options.
  
  Taken action would be one of the following:
  
  - if payment instruction is _NOT_ supplied and the account is on a manual payment,
    sets up one or two payment promise(s)
  - if payment instruction is _NOT_ supplied and the account is on an scheduled payment
    (direct debit/card), creates payment holiday
  - if payment instruction is supplied, sets up payment schedules for one or two instalment(s)
  
  
  A payment promise applies to an account that does not have automatic
  payments. It records that a customer has told us they'll pay an amount by
  an agreed-upon date.
  
  
  Payment Holiday means that when a customer is on a scheduled payment, the payments
  will not come out from customer's bank account for the period indicated.
  
  Expected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createPaymentExtension(
    """Input fields for creating a payment extension for the account"""
    input: CreatePaymentExtensionInput!
  ): CreatePaymentExtension

  """
  Reschedule an existing payment by a certain number of daysExpected `errorClass`:
  - AUTHORIZATION
  - APPLICATION
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  reschedulePayment(
    """Input fields for rescheduling a payment"""
    input: ReschedulePaymentInput!
  ): ReschedulePayment
  createCustomerSelfMeterRead(input: CustomerSelfMeterReadInput!): CreateCustomerSelfMeterRead @deprecated(reason: "Deprecated in favour of createCustomerSelfMeterReads field which supports multiple reading creations")
  createCustomerSelfMeterReads(readings: [CustomerSelfMeterReadInput]!): CreateCustomerSelfMeterReads

  """
  Taking a MIRN identifier trigger an async request to resolve its origin
  """
  requestMirnDiscovery(input: RequestMIRNDiscoveryInput!): RequestMIRNDiscovery

  """Mutation to process a house move in for a related account"""
  processHouseMoveIn(input: ProcessHouseMoveInInput!): ProcessHouseMoveIn @deprecated(reason: "\n**⚠️ This query is now deprecated for removal on 13-06-2021.\n\nIt is being replaced with the processHouseMoveInElectricity.\nFunctionally these are the same but with the processHouseMoveInGas\ncoming out we want to easily discern between the two.\n")

  """Mutation to process a house move in for a related account"""
  processHouseMoveInElectricity(input: ProcessHouseMoveInElectricityInput!): ProcessHouseMoveInElectricity

  """Mutation to process a house move out for a related account"""
  processHouseMoveOut(input: ProcessHouseMoveOutInput!): ProcessHouseMoveOut

  """Mutation to trigger an update the date of house move in or out"""
  updateProcessedHouseMoveDate(input: UpdateProcessedHouseMoveDateInput!): UpdateProcessedHouseMoveDate

  """Mutation to cancel a triggered move out process for a given account"""
  cancelHouseMoveOut(input: MoveOutCancelInput!): CancelHouseMoveOut
  updateConcession(input: UpdateConcessionInput!): UpdateConcession

  """Mutation to remove a concession for a user account"""
  removeConcession(input: RemoveConcessionInput!): RemoveConcession

  """Link an account user and line user together."""
  linkUserToLine(
    """Input fields to link an account user with LINE."""
    input: LinkUserToLineInput!
  ): LinkUserToLineResponse!

  """Unlink an account user and line together."""
  unlinkUserFromLine: UnlinkUserFromLineResponse!

  """Create an affiliate link for a new sales agent."""
  createAffiliateLink(
    """Input fields for creating an affiliate link for an organisation"""
    input: CreateAffiliateLinkInputType!
  ): CreateAffiliateLink!

  """Update an existing affiliate link."""
  updateAffiliateLink(
    """Input fields for Updating an existing affiliate link"""
    input: UpdateAffiliateLinkInputType!
  ): UpdateAffiliateLink!

  """Create an affiliate organisation."""
  createAffiliateOrganisation(
    """Input fields for creating an affiliate organisation"""
    input: CreateAffiliateOrganisationInputType!
  ): CreateAffiliateOrganisation!

  """Update an existing affiliate organisation."""
  updateAffiliateOrganisation(
    """Input fields for Updating an existing affiliate organisation"""
    input: UpdateAffiliateOrganisationInputType!
  ): UpdateAffiliateOrganisation!

  """Create a session for an affiliate link."""
  createAffiliateSession(
    """Input fields for creating a session for an affiliate link"""
    input: CreateAffiliateSessionInputType!
  ): CreateAffiliateSession!

  """Validate user's email address"""
  validateEmail(input: ValidateEmailInput!): ValidateEmail

  """Create metadata on an object."""
  createMetadata(
    """Input fields for creating metadata."""
    input: MetadataInput!
  ): CreateMetadata

  """Update metadata on an object."""
  updateMetadata(
    """Input fields for updating metadata."""
    input: MetadataInput!
  ): UpdateMetadata

  """
  Submit customer feedback.Expected `errorClass`:
  - NOT_FOUND
  - VALIDATION
  """
  submitCustomerFeedback(input: CustomerFeedbackInputType!): SubmitCustomerFeedback

  """Collect deposit for the given account."""
  collectDeposit(input: CollectDepositInput!): CollectDeposit

  """Record the customer's acceptance of a deposit agreement."""
  recordDepositAgreementAccepted(input: DepositAgreementInput!): RecordDepositAgreementAccepted

  """Create a new deposit agreement for the account if it needs one."""
  createDepositAgreement(input: CreateDepositAgreementInput!): CreateDepositAgreement

  """
  Initiate a standalone payment and return the client secret required to complete it.
  """
  initiateStandalonePayment(
    """Input fields for initiating a standalone payment."""
    input: InitiateStandalonePaymentInput!
  ): InitiateStandalonePayment

  """
  Get the client secret needed to create a new payment instruction using an embedded form.
  """
  getEmbeddedSecretForNewPaymentInstruction(
    """
    Input fields for getting the client secret for an embedded new card payment method form.
    """
    input: GetEmbeddedSecretForNewPaymentInstructionInput!
  ): GetEmbeddedSecretForNewPaymentInstruction

  """Store a new payment instruction created through the embedded process."""
  storePaymentInstruction(
    """
    Input fields for storing a new payment instruction created through the embedded process.
    """
    input: StorePaymentInstructionInput!
  ): StorePaymentInstruction

  """Invalidate an existing instruction."""
  invalidatePaymentInstruction(
    """
    Input fields for invalidating a payment instruction from an embedded form.
    """
    input: InvalidatePaymentInstructionInput!
  ): InvalidatePaymentInstruction

  """Set up a new direct debit instruction."""
  setUpDirectDebitInstruction(
    """Input fields for creating a new direct debit instruction"""
    input: SetUpDirectDebitInstructionInput!
  ): SetUpDirectDebitInstruction

  """
  Attempt to collect a one-off payment. If an instruction type is provided and there is an existing payment instruction, the payment can be collected immediately. A request to collect a payment at a future date can also be made, in which case the instruction input type is not necessary, but an instruction must exist at the specified collection date for the payment to be collected successfully.
  """
  collectPayment(
    """Input fields for collecting a payment."""
    input: CollectPaymentInput!
  ): CollectPayment

  """
  Get the client secret needed to collect an ad hoc payment using an embedded form.
  """
  getEmbeddedSecretForAdHocPayment(
    """
    Input fields for getting the client secret for an embedded one off payment form.
    """
    input: GetEmbeddedSecretForAdHocPaymentInput!
  ): GetEmbeddedSecretForAdHocPayment @deprecated(reason: "Please use 'initiateStandalonePayment' instead.")

  """Store a new card instruction from an embedded form."""
  storeCardPaymentInstruction(
    """Input fields for storing a new card instruction from an embedded form."""
    input: StoreCardPaymentInstructionInput!
  ): StoreCardPaymentInstruction @deprecated(reason: "Please use 'storePaymentInstruction' instead.")

  """Amend an existing payment."""
  amendPayment(
    """Input fields for amending an existing payment."""
    input: AmendPaymentInput!
  ): AmendPayment

  """Create an account reference."""
  createAccountReference(
    """Input fields for creating an account reference."""
    input: AccountReferenceInput!
  ): CreateAccountReference

  """Update an account reference."""
  updateAccountReference(
    """Input fields for updating an account reference."""
    input: AccountReferenceInput!
  ): UpdateAccountReference

  """Delete an account reference."""
  deleteAccountReference(
    """Input fields for removing an account reference."""
    input: DeleteAccountReferenceInput!
  ): DeleteAccountReference

  """Add credit to an account."""
  createAccountCredit(
    """Input fields for creating an account credit."""
    input: CreateAccountCreditInput!
  ): CreateAccountCredit

  """Add charge to an account."""
  createAccountCharge(
    """Input fields for creating an account charge."""
    input: CreateAccountChargeInput!
  ): CreateAccountCharge

  """
  Create a "form submission" entity. This is only meant to be used as a quick way of putting together a form and submit data for it, in the form of JSON - it is not expected that all form submissions will come through this path.
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  createFormSubmission(input: FormSubmissionInput!): FormSubmissionOuput

  """
  Provide username and password to receive a token. The token should be used as the Authentication header for any authenticated requests.
  """
  emailAuthentication(email: String!, password: String!): EmailAuthentication @deprecated(reason: "Please use obtainKrakenToken instead of this mutation.")

  """
  You probably want email authentication instead of this. Provide user's API Key to receive a token. The token should be used as the Authentication header for any authenticated requests. This form of authentication is used when the interface in question already has the API Key and it would be inappropriate to show the user a login screen.
  """
  apiKeyAuthentication(apiKey: String!): APIKeyAuthentication @deprecated(reason: "Please use obtainKrakenToken instead of this mutation.")

  """
  Provide a temporary token to get an auth token. This is intended to allow support users to view customer data through the brand interface.
  """
  masqueradeAuthentication(masqueradeToken: String!, userId: String!): MasqueradeAuthentication

  """Generate a pre-signed token with a set expiry time."""
  generatePreSignedToken(
    email: String!

    """
    The number of days that the token will be available for authentication (From now on).
    """
    numberOfDaysAllowed: Int!

    """Define (and limit) the scope of the token."""
    scope: PreSignedTokenScope!
  ): GeneratePreSignedToken

  """Invalidate a previously-issued pre-signed token."""
  invalidatePreSignedToken(input: InvalidatePreSignedTokenInput!): InvalidatePreSignedToken

  """Invalidate pre-signed tokens issued to a particular user."""
  invalidatePreSignedTokensForUser(input: InvalidatePreSignedTokensForUserInput!): InvalidatePreSignedTokensForUser

  """Deactivate the auth token used to authenticate the current request."""
  disableToken: DisableToken

  """
  Provide the email address of an account user to generate an email (to be sent to their address). The email will contain instructions on how to reset their password.
  """
  requestResetPassword(input: RequestResetPasswordMutationInput!): RequestResetPasswordMutationPayload

  """
  Reset the password of an account user indicated by the userId to the value supplied.
  """
  resetPassword(input: ResetPasswordMutationInput!): ResetPasswordMutationPayload

  """
  Create a Kraken Token (JWT) for authentication.  
  
  Provide the required input fields to obtain the token. 
  
  The token should be used as the Authentication header for any authenticated requests. 
  
  The keyword JWT must be added in front of the token. 
  
  Example:
  
  JWT eyJ0eXAiOiJKVBd....
  """
  obtainKrakenToken(
    """
    Input fields that can be used to obtain a Json Web Token (JWT) for authentication to the API.
    """
    input: ObtainJSONWebTokenInput!
  ): ObtainKrakenJSONWebToken

  """For authorized third-party organizations only."""
  obtainLongLivedRefreshToken(
    """
    Input fields for obtaining a long-lived refresh token to extend the expiry claim of a Kraken token.
    """
    input: ObtainLongLivedRefreshTokenInput!
  ): ObtainLongLivedRefreshToken

  """Invalidate a previously-issued refresh token."""
  invalidateRefreshToken(input: InvalidateRefreshTokenInput!): InvalidateRefreshToken

  """Invalidate refresh tokens issued to a particular user."""
  invalidateRefreshTokensForUser(input: InvalidateRefreshTokensForUserInput!): InvalidateRefreshTokensForUser

  """Create a shell/payment account."""
  createShellAccount(input: CreateShellAccountInput!): CreateShellAccountPayload

  """Update account communication delivery preference."""
  updateCommsDeliveryPreference(
    """Input fields for updating comms delivery preferences for an account"""
    input: UpdateCommsDeliveryPreferenceInput!
  ): UpdateCommsDeliveryPreference

  """Update address in legacy format for all accounts for this user"""
  updateUserAddress(
    """New billing address for user accounts"""
    address: UpdateAddressInput!
  ): UpdateUserAddressMutation

  """
  
  **⚠️ This type is currently in preview. During this time, it
     may change without warning in backwards-incompatible
     ways.**
  
  Update address for all accounts for this user
  
  """
  updateUserRichAddress(
    """New billing address for user accounts"""
    address: RichAddressInput!
  ): UpdateUserRichAddressMutation

  """Update address in legacy format for a single account"""
  updateAccountAddress(
    """The list of account numbers on which the address is to be updated"""
    accounts: [String]

    """New billing address for user accounts"""
    address: UpdateAddressInput!

    """
    The user for whom to perform the update. This is only needed when using an Organisation role
    """
    userId: String
  ): UpdateAccountAddressMutation

  """
  
  **⚠️ This type is currently in preview. During this time, it
     may change without warning in backwards-incompatible
     ways.**
  
  Update address for a single account
  
  """
  updateAccountRichAddress(
    """The list of account numbers on which the address is to be updated"""
    accounts: [String]

    """New billing address for user accounts"""
    address: RichAddressInput!

    """
    The user for whom to perform the update. This is only needed when using an Organisation role
    """
    userId: String
  ): UpdateAccountRichAddressMutation

  """Add a custom event for an account"""
  addCustomEvent(accountNumber: String!, category: String!, content: String!, subCategory: String): AddCustomEventMutation

  """Create a new account"""
  createAccount(
    """Input fields for creating user."""
    input: CreateAccountInput!
  ): CreateAccount

  """
  This mutation is used for processing an electricity product switch.This is when an existing user opts in for a different product during the tenure of their agreement.
  """
  updateAccountElectricityProduct(
    """Input fields for switching account electricity product."""
    input: UpdateAccountElectricityProductInput!
  ): UpdateAccountElectricityProduct

  """Create a new account user"""
  createAccountUser(input: CreateAccountUserInput!): CreateAccountUser

  """
  **DEPRECATED: Please use updateUser instead**
  
  Update the account user details of the authenticated user. Only one field can be updated per day. This prevents users from switching accounts to someone else (usually when moving homes) All account changes should be handled by operations or the move out journey. New customers are exempt from this rule for the first 31 days.
  """
  updateUserDetails(input: UpdateAccountUserMutationInput!): UpdateAccountUserMutationPayload

  """
  Update the comms preferences of the account user (the authenticated user).
  """
  updateCommsPreferences(input: UpdateAccountUserCommsPreferencesMutationInput!): UpdateAccountUserCommsPreferencesMutationPayload

  """
  Update password of the authenticated user
  
  Expected `errorClass`:
  - VALIDATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updatePassword(input: UpdatePasswordInput): UpdatePassword

  """
  Update the account user details of the authenticated user.
  
  firstName and givenName fields are blocked and can't be updated via this mutation. There is no limit in the number of fields and number of times they can be updated per day.
  
  Expected `errorClass`:
  - VALIDATION
  - AUTHORIZATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  updateUser(
    """Input fields for updating user."""
    input: UpdateUserInput!
  ): UpdateUserMutation

  """
  Register a device token to be used for push notifications for an app.
  
  Expected `errorClass`:
  - APPLICATION
  - NOT_FOUND
  - AUTHORIZATION
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  registerPushNotificationBinding(
    """Input fields for creating an push notification binding."""
    input: RegisterPushNotificationBindingInput!
  ): RegisterPushNotificationBinding
}

type CreateElectricityQuote {
  quote: QuoteType
  meterPoint: MeterPointType
}

type QuoteType {
  """"""
  id: ID!

  """"""
  code: String

  """"""
  postcode: String!

  """"""
  includesElectricity: Boolean!

  """"""
  includesGas: Boolean!

  """"""
  includesExport: Boolean

  """"""
  meterType: QuoteMeterType!

  """"""
  createdAt: DateTime!

  """"""
  products: [QuotedProduct!]!
}

"""An enumeration."""
enum QuoteMeterType {
  """No meter (for gas-only customers)"""
  NO_METER

  """Standard"""
  STANDARD

  """Economy 7"""
  ECONOMY7

  """Smart meter"""
  SMART

  """Smart Economy7"""
  SMART_ECONOMY7

  """Smart Flat Economy7"""
  SMART_FLAT_ECONOMY7

  """Flat Economy7"""
  FLAT_ECONOMY7

  """Three-rate"""
  THREE_RATE

  """Flat three-rate"""
  FLAT_THREE_RATE

  """Other"""
  OTHER
}

type QuotedProduct {
  """"""
  id: ID!

  """"""
  name: String!

  """"""
  description: String!

  """"""
  monthlyAmount: Int!

  """"""
  annualAmount: Int!

  """"""
  elecAnnualAmount: Int!

  """"""
  gasAnnualAmount: Int!
  code: String
  isRecommended: Boolean
}

input CreateElectricityQuoteInput {
  """The nmi to look for"""
  nmi: String!
  contactUserId: ID
  isBusiness: Boolean!
}

type CreateGasQuote {
  quoteRequest: QuoteRequestType
  error: CreateGasQuoteErrorUnion
}

type QuoteRequestType {
  """"""
  id: ID!

  """"""
  code: UUID!
}

"""
Leverages the internal Python implmeentation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

union CreateGasQuoteErrorUnion = PropertyNotFoundErrorType | NoSupplyPointsFoundOnPropertyErrorType | TermsAndConditionsCanNotBeFoundErrorType | NoSuitableProductsFoundErrorType | UnsupportedMarketErrorType

type PropertyNotFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type NoSupplyPointsFoundOnPropertyErrorType implements GenericErrorInterfaceType {
  message: String!
}

type TermsAndConditionsCanNotBeFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type NoSuitableProductsFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type UnsupportedMarketErrorType implements GenericErrorInterfaceType {
  message: String!
}

input CreateGasQuoteInput {
  propertyId: Int!
  isBusiness: Boolean!
}

type UpdateCreditCardInstruction {
  creditCardInstruction: DirectDebitInstructionType
}

input UpdateCreditCardInstructionInput {
  accountNumber: String!
  creditCardInstructionAttributes: CreditCardInstructionAttributesInput!
}

input CreditCardInstructionAttributesInput {
  id: String!
  expiryMonth: String!
  expiryYear: String!
}

type CreateDirectDebitInstruction {
  directDebitInstruction: DirectDebitInstructionType
}

input CreateDirectDebitInstructionInput {
  accountNumber: String!
  directDebitInstruction: DirectDebitInstructionLocalBankDetailsInput!
}

input DirectDebitInstructionLocalBankDetailsInput {
  accountNumber: String!
  accountHolder: String!
  sortCode: String!
}

type ReplacePaymentSchedule {
  replacedSchedule: PaymentScheduleType
}

input ReplacePaymentScheduleInput {
  accountNumber: String!
  paymentScheduleId: String!
}

type CreateCreditCardInstruction {
  creditCardInstruction: DirectDebitInstructionType
}

input CreateCreditCardInstructionInput {
  accountNumber: String!
  vendorCardIdentifier: String!
}

type CreatePaymentSchedule {
  paymentSchedule: PaymentScheduleType
}

input PaymentScheduleInput {
  """Enter your account number."""
  accountNumber: String!

  """Input a schedule type."""
  scheduleType: ScheduleTypeInputChoices!
}

enum ScheduleTypeInputChoices {
  DIRECT_DEBIT
  CARD_PAYMENT
}

type DeletePaymentInstruction {
  paymentInstruction: DirectDebitInstructionType
}

input DeletePaymentInstructionInput {
  accountNumber: String!
  paymentInstructionId: String!
}

type MakePaymentWithNewCard {
  accountPayment: AccountPaymentType
  creditCardInstruction: DirectDebitInstructionType
}

input MakePaymentWithNewCardInput {
  accountNumber: String!
  vendorCardIdentifier: String!

  """Payment amount in cents"""
  amount: Int!

  """Whether to save the card or not"""
  saveCard: Boolean!
}

type MakePaymentWithSavedCard {
  accountPayment: AccountPaymentType
}

input MakePaymentWithSavedCardInput {
  accountNumber: String!
  paymentInstructionId: String!
  amount: Int!

  """Date that the customer is expected to pay by."""
  paymentDate: Date
}

type SetupPaymentDetails {
  paymentInstruction: PaymentInstructionType
}

input SetupPaymentDetailsInput {
  accountNumber: String!
  paymentMethod: PaymentMethod

  """Credit Card token"""
  cardToken: String

  """Name on the account"""
  ddAccountName: String

  """Account Number"""
  ddAccountNumber: String

  """Account BSB number"""
  ddAccountBsb: String
}

"""The method chosen to make payments for the account"""
enum PaymentMethod {
  VARIABLE_DIRECT_DEBIT
  VARIABLE_CARD
}

"""

Creates payment extension according to the recieved options.

Taken action would be one of the following:

- if payment instruction is _NOT_ supplied and the account is on a manual payment,
  sets up one or two payment promise(s)
- if payment instruction is _NOT_ supplied and the account is on an scheduled payment
  (direct debit/card), creates payment holiday
- if payment instruction is supplied, sets up payment schedules for one or two instalment(s)


A payment promise applies to an account that does not have automatic
payments. It records that a customer has told us they'll pay an amount by
an agreed-upon date.


Payment Holiday means that when a customer is on a scheduled payment, the payments
will not come out from customer's bank account for the period indicated.


"""
type CreatePaymentExtension {
  paymentExtension: PaymentExtensionUnionType
}

union PaymentExtensionUnionType = PaymentPromiseType | PaymentScheduleType | AccountPaymentType

"""

A payment promise applies to an account that does not have automatic
payments. It records that a customer has told us they'll pay an amount by
an agreed-upon date.


"""
type PaymentPromiseType {
  paymentPromises: [AccountPaymentType]
}

input CreatePaymentExtensionInput {
  accountNumber: String!

  """The start date the payment extension would be applied by"""
  chosenDate: Date!

  """The length of instalment to use for this payment extension"""
  chosenOption: PaymentExtensionOption!

  """
  The ledger of the payment. Defaults to the main ledger when no ID is passed.
  """
  ledgerId: Int
  paymentInstructionId: String
}

"""Available options for extending the payment"""
enum PaymentExtensionOption {
  PAY_IN_FULL
  WEEKLY
  FORTNIGHTLY
}

type ReschedulePayment {
  newAccountPayment: AccountPaymentType
}

input ReschedulePaymentInput {
  accountNumber: String!

  """Payment Id to be rescheduled"""
  paymentId: Int!

  """Days to extend the payment by"""
  numDays: Int!
}

type CreateCustomerSelfMeterRead {
  reading: ElectricityAccumulationMeterReadingType
}

input CustomerSelfMeterReadInput {
  registerId: Int!
  value: String!
  readAt: DateTime!
}

type CreateCustomerSelfMeterReads {
  readings: [ElectricityAccumulationMeterReadingType]
  error: ReadingValidationSaveErrorUnion
}

union ReadingValidationSaveErrorUnion = MultipleMeterpointsValidationErrorType | MissingReadingsValidationErrorType | MissingAccountForRegisterValidationErrorType | InvalidTimezoneReadAtDateValidationErrorType | UnableToValidateReadingType

type MultipleMeterpointsValidationErrorType implements GenericErrorInterfaceType {
  message: String!
}

type MissingReadingsValidationErrorType implements GenericErrorInterfaceType {
  message: String!
}

type MissingAccountForRegisterValidationErrorType implements GenericErrorInterfaceType {
  message: String!
}

type InvalidTimezoneReadAtDateValidationErrorType implements GenericErrorInterfaceType {
  message: String!
}

type UnableToValidateReadingType implements GenericErrorInterfaceType {
  message: String!
}

type RequestMIRNDiscovery {
  discoveryRequest: MDHXProcessDiscoveryType
  error: MIRNDiscoveryErrorUnion
}

type MDHXProcessDiscoveryType {
  """"""
  id: ID!

  """"""
  correlationId: String!
  processType: MDHXProcessType
  currentStatus: MDHXStatusReason

  """"""
  statusReason: String
}

"""An enumeration."""
enum MDHXProcessType {
  """Mirn Discovery"""
  MIRN_DISCOVERY

  """Customer Transfer"""
  CUSTOMER_TRANSFER

  """Account Creation Notification"""
  ACCOUNT_CREATION_NOTIFICATION

  """Customer Details Notification"""
  CUSTOMER_DETAILS_NOTIFICATION

  """Customer Details Request"""
  CUSTOMER_DETAILS_REQUEST

  """Life Support Request"""
  LIFE_SUPPORT_REQUEST

  """Life Support Notification"""
  LIFE_SUPPORT_NOTIFICATION

  """Amend Site Access Details"""
  AMEND_SITE_ACCESS_DETAILS

  """Amend Site Address Details"""
  AMEND_SITE_ADDRESS_DETAILS

  """Missing Meter Data Notification"""
  MISSING_METER_DATA_NOTIFICATION

  """Meter Data Verify Request"""
  METER_DATA_VERIFY_REQUEST

  """Meter Read Input Notification"""
  METER_READ_INPUT_NOTIFICATION

  """Meter Data Notification"""
  METER_DATA_NOTIFICATION

  """Time Expired Meters"""
  TIME_EXPIRED_METERS

  """Mains Service Renewal"""
  MAINS_SERVICE_RENEWAL

  """Special Read"""
  SPECIAL_READ

  """Service Order"""
  SERVICE_ORDER

  """Standing Data Update Notification"""
  STANDING_DATA_UPDATE_NOTIFICATION
}

"""An enumeration."""
enum MDHXStatusReason {
  """Request Received"""
  REQUEST_RECEIVED

  """Request Accepted"""
  REQUEST_ACCEPTED

  """Rejected"""
  FAILED

  """Completed"""
  COMPLETED

  """Discovery Request Sent"""
  DISCOVERY_REQUEST_SENT

  """Multiple Mirns Found"""
  MULTIPLE_MIRNS_FOUND

  """Partial Standing Data Received"""
  PARTIAL_STANDING_DATA_RECEIVED

  """Standing Data Request Sent"""
  STANDING_DATA_REQUEST_SENT

  """Pre Registration"""
  PRE_REGISTRATION

  """Initiated"""
  INITIATED

  """Pending Validation"""
  PENDING_VALIDATION

  """Requested"""
  REQUESTED

  """Pending"""
  PENDING

  """Cancelled"""
  CANCELLED

  """Rejected"""
  REJECTED

  """Objected"""
  OBJECTED

  """Read Failure"""
  READ_FAILURE

  """ACN Received"""
  ACN_RECEIVED

  """CDN Request Sent"""
  CDN_REQUEST_SENT

  """Life Support Notification Sent"""
  LIFE_SUPPORT_NOTIFICATION_SENT

  """Life Support Notification Received"""
  LIFE_SUPPORT_NOTIFICATION_RECEIVED

  """Customer Details Request Received"""
  CUSTOMER_DETAILS_REQUEST_RECEIVED

  """Customer Details Request Notification Sent"""
  CUSTOMER_DETAILS_REQUEST_NOTIFICATION_SENT

  """Life Support Request Sent"""
  LIFE_SUPPORT_REQUEST_SENT

  """Life Support Request Notification Received"""
  LIFE_SUPPORT_REQUEST_NOTIFICATION_RECEIVED

  """Life Support Request Received"""
  LIFE_SUPPORT_REQUEST_RECEIVED

  """Life Support Request Notification Sent"""
  LIFE_SUPPORT_REQUEST_NOTIFICATION_SENT

  """Site Access Details Request Sent"""
  SITE_ACCESS_DETAILS_REQUEST_SENT

  """Site Access Details Received"""
  SITE_ACCESS_DETAILS_RECEIVED

  """Site Address Details Request Sent"""
  SITE_ADDRESS_DETAILS_REQUEST_SENT

  """Site Address Details Received"""
  SITE_ADDRESS_DETAILS_RECEIVED

  """Missing Meter Data Notification Sent"""
  MISSING_METER_DATA_NOTIFICATION_SENT

  """Meter Data Verify Request Sent"""
  METER_DATA_VERIFY_REQUEST_SENT

  """Meter Data Verify Response Received"""
  METER_DATA_VERIFY_RESPONSE_RECEIVED

  """Meter Read Input Sent"""
  METER_READ_INPUT_SENT

  """Meter Data Notification Received"""
  METER_DATA_NOTIFICATION_RECEIVED

  """Meter Data Response Sent"""
  METER_DATA_RESPONSE_SENT

  """Time Expired Meters Received"""
  TIME_EXPIRED_METERS_RECEIVED

  """Mains Service Renewal Received"""
  MAINS_SERVICE_RENEWAL_RECEIVED

  """Special Read Request Sent"""
  SPECIAL_READ_REQUEST_SENT

  """Initial Special Read Response Received"""
  INITIAL_SPECIAL_READ_RESPONSE_RECEIVED

  """Closure Special Read Response Received"""
  CLOSURE_SPECIAL_READ_RESPONSE_RECEIVED

  """Unsolicited Special Read Response Received"""
  UNSOLICITED_SPECIAL_READ_RESPONSE_RECEIVED

  """Cancellation Special Read Sent"""
  CANCELLATION_SPECIAL_READ_SENT

  """Failed Special Read Response Received"""
  FAILED_SPECIAL_READ_RESPONSE_RECEIVED

  """Cancellation Failed Special Read Response Received"""
  CANCELLATION_FAILED_SPECIAL_READ_RESPONSE_RECEIVED

  """Service Order Request Sent"""
  SERVICE_ORDER_REQUEST_SENT

  """Initial Service Order Response Received"""
  INITIAL_SERVICE_ORDER_RESPONSE_RECEIVED

  """Closure Service Order Response Received"""
  CLOSURE_SERVICE_ORDER_RESPONSE_RECEIVED

  """Unsolicited Service Order Response Received"""
  UNSOLICITED_SERVICE_ORDER_RESPONSE_RECEIVED

  """Cancellation Service Order Sent"""
  CANCELLATION_SERVICE_ORDER_SENT

  """Cancellation Failed Service Order Response Received"""
  CANCELLATION_FAILED_SERVICE_ORDER_RESPONSE_RECEIVED

  """Failed Service Order Response Received"""
  FAILED_SERVICE_ORDER_RESPONSE_RECEIVED

  """Standing Data Update Notification Received"""
  STANDING_DATA_UPDATE_NOTIFICATION_RECEIVED
}

union MIRNDiscoveryErrorUnion = MIRNDiscoveryRequestAlreadyTriggeredErrorType | UnableToPerformDiscoveryErrorType | InvalidDiscoveryRequestErrorType

type MIRNDiscoveryRequestAlreadyTriggeredErrorType implements GenericErrorInterfaceType {
  message: String!
}

type UnableToPerformDiscoveryErrorType implements GenericErrorInterfaceType {
  message: String!
}

type InvalidDiscoveryRequestErrorType implements GenericErrorInterfaceType {
  message: String!
}

input RequestMIRNDiscoveryInput {
  mirn: ID
}

"""
NOTE this whole mutation is deprecated for removal on 13-06-2021.
Functionally it is the same as ProcessHouseMoveInElectricity
the only difference being a change of naming in mutation and types.
"""
type ProcessHouseMoveIn {
  account: AccountType
}

"""
NOTE this is here for deprecation reasons. Remove with the removal of the
processedHouseMoveIn mutation on or after 13-06-2021.
"""
input ProcessHouseMoveInInput {
  isBusiness: Boolean!
  contactUserId: ID!
  nmi: String!
  moveInDate: Date!
  quotedProductId: ID!
  appointmentDetails: AppointmentDetails!
  preferences: PreferenceDetails!
  isMoveIn: Boolean = true
}

input AppointmentDetails {
  preferredTime: AppointmentChoices!
  appointmentAccess: String!
  specialInstructions: String!
  accessDetails: String!
  hazards: [HazardType]
  hazardDetails: String
  safetyCertificateId: ID
  safetyCertificateMethodSent: MethodSent
}

"""An enumeration."""
enum AppointmentChoices {
  EMPTY
  T0800_1300
  T0900_1400
  T1000_1500
  T1100_1600
  T1200_1700
  T1300_1800
}

"""An enumeration."""
enum HazardType {
  """Asbestos Board"""
  ASBESTOS_BOARD

  """Asbestos Fuse"""
  ASBESTOS_FUSE

  """Customer Caution"""
  CUSTOMER_CAUTION

  """Dog"""
  DOG

  """Electric Fence"""
  ELECTRIC_FENCE

  """Electrical Safety Issue"""
  ELECTRICAL_SAFETY_ISSUE

  """Customer Reports No Hazard"""
  CUSTOMER_REPORTS_NO_HAZARD

  """Not Known"""
  NOT_KNOWN
}

"""An enumeration."""
enum MethodSent {
  """Faxed"""
  FAXED

  """Email"""
  EMAIL

  """Online"""
  ONLINE

  """OnSite"""
  ON_SITE
}

input PreferenceDetails {
  requiresPostalComms: Boolean!
  postalSameAsSupply: Boolean!
  postalAddress: PostalAddressInput
  billingPeriod: PeriodLength!
  optIntoMarketing: Boolean!
}

input PostalAddressInput {
  flatOrUnitType: FlatUnitType
  flatOrUnitNumber: String
  floorOrLevelType: FloorLevelType
  floorOrLevelNumber: String
  buildingOrPropertyName: String
  locationDescriptor: String
  houseNumber1: String
  houseNumberSuffix1: String

  """
  Additional house number, use when address contains multiple house numbers
  """
  houseNumber2: String

  """
  Additional house number suffix, use when address contains multiple house number suffixes
  """
  houseNumberSuffix2: String
  lotNumber: String
  streetName: String
  streetType: StreetType
  streetSuffix: StreetSuffix
  postalDeliveryType: PostalDeliveryType
  postalDeliveryNumberPrefix: String
  postalDeliveryNumberValue: String
  postalDeliveryNumberSuffix: String

  """Suburb/Locality"""
  locality: String
  administrativeArea: StateTerritory
  postalCode: String
}

"""

    Postal delivery types defined in aseXML schema ClientInformation_r36.xsd

    Valid for aseXML revisions from r36-r41 (possibly future revisions too)

    From the schema:
    Purpose - Define postal delivery types as per Australian Standard AS4590:2006
    Detail - There are several additions in this list over and above what is in
    AS4590:2006. The extra types have been derived from the Australia Post AMAS
    standard.
    -- Version 5.0 additions
    -- Element AustralianPostalDeliveryType has been restricted to 11 characters
    
"""
enum PostalDeliveryType {
  """Care Po"""
  CARE_PO

  """Cma"""
  CMA

  """Cmb"""
  CMB

  """Cpa"""
  CPA

  """Gpo Box"""
  GPO_BOX

  """Locked Bag"""
  LOCKED_BAG

  """Ms"""
  MS

  """Po Box"""
  PO_BOX

  """Private Bag"""
  PRIVATE_BAG

  """Rsd"""
  RSD

  """Rmb"""
  RMB

  """Rms"""
  RMS
}

"""An enumeration."""
enum PeriodLength {
  MONTHLY
  QUARTERLY
}

"""
Mutation for triggering a move in process for a defined user.
Allows configuration of the users:
 - Move in details
 - Billing preferences
 - Life support status (*This is pending future work)

This mutation depending on the related users state in kraken will either
return or create an account within kraken.
"""
type ProcessHouseMoveInElectricity {
  account: AccountType
}

input ProcessHouseMoveInElectricityInput {
  isBusiness: Boolean!
  contactUserId: ID!
  nmi: String!
  moveInDate: Date!
  quotedProductId: ID!
  appointmentDetails: AppointmentDetails!
  preferences: PreferenceDetails!
  isMoveIn: Boolean = true
}

type ProcessHouseMoveOut {
  account: AccountType
  error: ProcessHouseMoveOutErrorUnion
}

union ProcessHouseMoveOutErrorUnion = MoveOutAlreadyProcessedErrorType | UnableToCompleteMoveErrorType

type MoveOutAlreadyProcessedErrorType implements GenericErrorInterfaceType {
  message: String!
}

type UnableToCompleteMoveErrorType implements GenericErrorInterfaceType {
  message: String!
}

input ProcessHouseMoveOutInput {
  accountNumber: ID!
  moveOutDate: Date!

  """ID of property that the account wants to move out from"""
  propertyId: ID!
}

type UpdateProcessedHouseMoveDate {
  account: AccountType
  error: UpdateProcessedHouseMoveDateErrorUnion
}

union UpdateProcessedHouseMoveDateErrorUnion = ExistingBillingOverMoveInAdjustmentErrorType | UnableToAdjustMoveDateErrorType

type ExistingBillingOverMoveInAdjustmentErrorType implements GenericErrorInterfaceType {
  message: String!
}

type UnableToAdjustMoveDateErrorType implements GenericErrorInterfaceType {
  message: String!
}

input UpdateProcessedHouseMoveDateInput {
  updatedMoveDate: Date!

  """
  ID of the occupancy period related to the property the account is to be moved out from
  """
  occupancyPeriodId: ID!
}

type CancelHouseMoveOut {
  account: AccountType
  error: CancelHouseMoveErrorUnion
}

union CancelHouseMoveErrorUnion = UnableToUndoMoveErrorType

type UnableToUndoMoveErrorType {
  message: String!
}

input MoveOutCancelInput {
  accountNumber: ID!

  """
  ID of the occupancy period related to the property the account is to be moved out from
  """
  occupancyPeriodId: ID!
}

type UpdateConcession {
  concession: ConcessionType
  primaryResidence: PrimaryResidenceType
}

input UpdateConcessionInput {
  cardType: ConcessionCardType!
  cardNumber: String!

  """
  The user for whom to perform the update. This is only needed when using an Organisation role
  """
  userId: String
  primaryResidence: PrimaryResidenceInput
}

input PrimaryResidenceInput {
  """ID of the current associated primary residence of the user"""
  currentPrimaryResidenceId: Int

  """ID of property to associate user too as their primary residence"""
  propertyId: Int!

  """Primary residence applies from this date"""
  fromDate: Date!

  """Primary residence no longer applies from this date"""
  toDate: Date!

  """
  Allow this primary residence to overlap with an existing primary residence if the property is different. Typically, you would only do this if the customer has accounts with multiple fuels.
  """
  allowOverlappingPeriods: Boolean!

  """
  Force end an overlapping period for the same property. You should only need to do this if the primary residence property was not ended correctly for a previous customer.
  """
  forceEndOverlappingProperty: Boolean!
}

type RemoveConcession {
  concession: ConcessionType
}

input RemoveConcessionInput {
  """Date at which the concession removal was validated."""
  removalDate: Date!

  """
  The user for whom to perform the removal. This is only needed when using an Organisation role
  """
  userId: String
}

union LinkUserToLineResponse = LineLinkRedirectResponse | LinkTokenNotFound | AlreadyLinkedError

"""Link Successful. Complete link process with LINE."""
type LineLinkRedirectResponse {
  redirectUrl: String!
}

"""
Returned when no LineAccountLink record matching the parameters exists.
"""
type LinkTokenNotFound {
  """The type of error that occurred."""
  type: LineLinkErrorType!
}

enum LineLinkErrorType {
  NO_MATCHING_LINE_LINK
  ALREADY_LINKED
}

"""Returned when an account already has a LINE account linked to it."""
type AlreadyLinkedError {
  """The type of error that occurred."""
  type: LineLinkErrorType!
}

"""Link an AccountUser to a LINE account."""
input LinkUserToLineInput {
  linkToken: String!
}

union UnlinkUserFromLineResponse = LineUnlinkedResponse | LinkTokenNotFound | LineCommonError

type LineUnlinkedResponse {
  message: String!
}

"""
A base error type. Should be used for general application or lower level errors.
"""
type LineCommonError {
  """The error message to display to the user."""
  message: String!

  """The field that for which this error should be associated"""
  field: String
}

"""Create an affiliate link for a new sales agent."""
type CreateAffiliateLink {
  affiliateLink: AffiliateLinkType
}

input CreateAffiliateLinkInputType {
  """The organisation for whom to create the affiliate link for."""
  organisationId: ID!

  """
  
  Will be validated as follows:
  
  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  """
  subdomain: String!
  contactName: String!
  contactEmail: String!
}

"""Update an affiliate link of an existing sales agent."""
type UpdateAffiliateLink {
  affiliateLink: AffiliateLinkType
}

input UpdateAffiliateLinkInputType {
  """The id of the affiliate link that is going to be edited."""
  linkId: ID!

  """The organisation for whom to update the affiliate link for."""
  organisationId: ID

  """
  
  Will be validated as follows:
  
  - should be at least two characters
  - should only contain (letters, numbers, and Hyphen)
  - should not contain bad words
  - should not contain any of the reserved words including:
   affiliates, api, business, click, consul, developer, friends, kraken, mail, sendgrid, tech, webhooks, www, www2
  """
  subdomain: String
  contactName: String
  contactEmail: String
  isBusiness: Boolean
  landingUrl: String
  trainingStatus: String
}

"""Create an affiliate organisation."""
type CreateAffiliateOrganisation {
  affiliateOrganisation: AffiliateOrganisationType
}

input CreateAffiliateOrganisationInputType {
  name: String!

  """Sales Channel"""
  salesChannel: SalesChannelChoices!

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices!

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""Update an affiliate organisation."""
type UpdateAffiliateOrganisation {
  affiliateOrganisation: AffiliateOrganisationType
}

input UpdateAffiliateOrganisationInputType {
  """The organisation that is going to be edited."""
  organisationId: ID!
  name: String

  """Sales Channel"""
  salesChannel: SalesChannelChoices

  """Default Account Type"""
  defaultAccountType: AccountTypeChoices

  """
  Are meter point registrations limited for profile classes 1 and 2 for registrations from csv or API
  """
  canRegisterBusinessMeterPoints: Boolean

  """
  Allow registration requests with exiting account user emails to add to the portfolio belonging to the account user.
  """
  canRegisterPortfolioAccounts: Boolean

  """Allow registration requests with customers without an email address."""
  canRegisterCustomersWithoutEmailAddress: Boolean

  """
  Allow this partner to skip validation that ensures all meter points belong to the same address
  """
  skipMeterPointAddressValidation: Boolean

  """
  Is this partner allowed to specify payment methods other than Direct Debit in the import csv or API
  """
  allowAlternativePaymentMethods: Boolean

  """Allow performing tariff renewals via API."""
  canRenewTariffs: Boolean

  """
  Allow this partner access to the IVR support API (modify their own IVR handling through third party 'IVR Flow Editor')
  """
  canUseIvrSupportApi: Boolean

  """
  Restrict to field-sales-only products? This is only allowed for the 'field-sales' and 'events' sales channels
  """
  isFieldSalesOnlyProduct: Boolean
}

"""Create a session for an affiliate link."""
type CreateAffiliateSession {
  affiliateSession: AffiliateSessionType
}

"""A tracked session for the affiliate link."""
type AffiliateSessionType {
  """"""
  id: ID!

  """"""
  ipAddress: String

  """"""
  userAgent: String!

  """"""
  queryParams: JSONString!
  link: AffiliateLinkType
}

input CreateAffiliateSessionInputType {
  """The affiliate link for whom to create the session for."""
  linkId: ID!

  """The IP Address of the user."""
  ipAddress: String

  """The HTTP user agent."""
  userAgent: String

  """Additional query parameters to attach to this session."""
  queryParams: JSONString

  """The quote share that led to this session."""
  quoteShareId: ID
}

"""Validate whether a user's email is a valid email via the Kickbox API."""
type ValidateEmail {
  isValid: Boolean
}

"""Input required to validate email address via Kickbox"""
input ValidateEmailInput {
  """The user's email address"""
  email: String!
}

"""Create metadata on an object."""
type CreateMetadata {
  metadata: Metadata
}

"""The metadata input type for mutations."""
input MetadataInput {
  """
  An identifier for the associated object, e.g. account_number for the Account linked object type.
  """
  identifier: String!

  """The object that the metadata is associated with."""
  linkedObjectType: LinkedObjectType!

  """The key for the metadata."""
  key: String!

  """The metadata value which should be a valid JSON string."""
  value: JSONString!
}

"""Update existing metadata on an object."""
type UpdateMetadata {
  metadata: Metadata
}

type SubmitCustomerFeedback {
  customerFeedback: CustomerFeedbackType
}

type CustomerFeedbackType {
  """"""
  id: ID!

  """The value attached to the source"""
  rawScore: Int

  """The datetime the feedback was submitted"""
  submittedAt: DateTime
}

input CustomerFeedbackInputType {
  answer: String
  issueResolved: Boolean!
  formId: Int!
  feedbackId: Int!
  accountNumber: String!
}

"""Collect deposit for the given account."""
type CollectDeposit {
  payment: CollectDepositOutput
}

type CollectDepositOutput {
  status: CollectDepositStatusChoices
  paymentDate: Date
}

enum CollectDepositStatusChoices {
  APPROVED
  CLEARED
  CANCELLED
  HELD_FOR_REVIEW
  FAILED
  PENDING
  REQUESTED
  SCHEDULED
  NONE
}

input CollectDepositInput {
  accountNumber: String!
  depositKey: String!
  idempotencyKey: String!
}

"""Record the customer's acceptance of a deposit agreement."""
type RecordDepositAgreementAccepted {
  isRecorded: Boolean
}

input DepositAgreementInput {
  accountNumber: String!
  depositKey: String!
}

"""Create a new deposit agreement for the account if it needs one."""
type CreateDepositAgreement {
  depositAgreement: CreateDepositAgreementOutput
}

type CreateDepositAgreementOutput {
  depositRequired: Boolean
  depositAmount: Int
}

input CreateDepositAgreementInput {
  accountNumber: String!
  depositKey: String!
  reason: String!
}

"""
Initiate a standalone payment and return the client secret required to complete it.
"""
type InitiateStandalonePayment {
  payment: InitiateStandalonePaymentOutput
}

"""Tokens required to collect and retrieve a standalone payment."""
type InitiateStandalonePaymentOutput {
  """The retrieval token for this standalone payment."""
  retrievalToken: String!

  """The secret used to collect the payment."""
  secretToken: String!
}

"""Input fields for initiating a standalone payment."""
input InitiateStandalonePaymentInput {
  """The account number."""
  accountNumber: String!

  """The amount to be collected."""
  amount: Int!

  """A description of the purpose of the payment."""
  description: String!
}

"""
Get the client secret needed to create a new payment instruction using an embedded form.
"""
type GetEmbeddedSecretForNewPaymentInstruction {
  secretKey: String
}

"""
The input for getting the client secret for an embedded new card payment method form.
"""
input GetEmbeddedSecretForNewPaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The type of the new payment instruction."""
  instructionType: PaymentType!
}

"""
Store a new new payment instruction created through the embedded process.
"""
type StorePaymentInstruction {
  paymentInstruction: PaymentInstructionType
}

"""
The input for storing a new payment instruction created through the embedded process.
"""
input StorePaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The type of the new payment instruction."""
  instructionType: PaymentType!

  """The datetime from which the instruction is vaild."""
  validFrom: DateTime!

  """The vendor's reference for this payment method."""
  vendorReference: String!
}

"""Invalidates a payment instruction."""
type InvalidatePaymentInstruction {
  instruction: InvalidatePaymentInstructionOutput
}

"""Output for invalidating an arbitrary payment instruction."""
type InvalidatePaymentInstructionOutput {
  id: Int
}

"""Input for invalidating an arbitrary payment instruction."""
input InvalidatePaymentInstructionInput {
  accountNumber: String!

  """The id of the payment instruction to be invalidated."""
  id: String!
}

type SetUpDirectDebitInstruction {
  paymentInstruction: DirectDebitInstructionType
}

input SetUpDirectDebitInstructionInput {
  accountNumber: String!
  ledgerId: ID!
  validFrom: DateTime!
  bankDetails: BankDetailsInput!
}

input BankDetailsInput {
  accountHolder: String
  iban: String
  accountNumber: String
  bankCode: String
  branchCode: String
  accountType: String
}

type CollectPayment {
  """
  Details about the collected payment. Note that we might not be able to collect the payment (e.g. if there is no usable payment instruction), in which case the status of the returned payment might be failed or cancelled.
  """
  payment: AccountPaymentType
}

input CollectPaymentInput {
  """The account number."""
  accountNumber: String!

  """The payment amount (in cents)."""
  amount: Int!

  """
  ('The date to attempt to take the payment. Cannot be a date in the past. Payment will be collected on the requested date or as soon as possible after that date.',)
  """
  paymentDate: Date!

  """The reason a payment is being collected, for internal audit purposes"""
  description: String!
  idempotencyKey: String!

  """The type of the payment instruction."""
  collectionMethod: PaymentType

  """The ID of the ledger on which to collect the payment."""
  ledgerId: ID!
}

"""
Get the client secret needed to collect an ad hoc payment using an embedded form.
"""
type GetEmbeddedSecretForAdHocPayment {
  secretKey: String
}

"""
The input for getting the client secret for an embedded one off payment method form.
"""
input GetEmbeddedSecretForAdHocPaymentInput {
  """The account number."""
  accountNumber: String!

  """The amount to be charged."""
  amount: Int!

  """A description of the purpose of the payment."""
  description: String!
}

"""Store a new card instruction for Electric Juice from an embedded form."""
type StoreCardPaymentInstruction {
  paymentInstruction: PaymentInstructionType
}

"""The input for storing a new card instruction from an embedded form."""
input StoreCardPaymentInstructionInput {
  """The account number."""
  accountNumber: String!

  """The datetime from which the instruction is vaild."""
  validFrom: DateTime!

  """The vendor's reference for this payment method."""
  vendorReference: String!
}

type AmendPayment {
  payment: AccountPaymentType
}

input AmendPaymentInput {
  """The account number."""
  accountNumber: String!

  """The ID of the payment to amend."""
  paymentId: Int!

  """The new amount for the amended payment"""
  amount: Int!

  """The new date to collect the payment"""
  paymentDate: Date!

  """Reason for amending the payment."""
  reason: String
}

"""Create an account reference."""
type CreateAccountReference {
  accountReference: AccountReferenceType
}

"""The input type for the account reference."""
input AccountReferenceInput {
  """The account number."""
  accountNumber: String!

  """The namespace for the reference."""
  namespace: String!

  """The reference value."""
  value: String!
}

"""Update a reference for a particular account and namespace."""
type UpdateAccountReference {
  accountReference: AccountReferenceType
}

"""Delete a reference for a particular account and namespace."""
type DeleteAccountReference {
  accountReference: DeleteAccountReferenceType
}

type DeleteAccountReferenceType {
  """The namespace associated with the removed AccountReference"""
  namespace: String!
}

input DeleteAccountReferenceInput {
  """The account number associated with the removed AccountReference."""
  accountNumber: String!

  """The namespace associated with the removed AccountReference"""
  namespace: String!
}

"""Add credits to an account."""
type CreateAccountCredit {
  accountCredit: AccountCreditType
}

type AccountCreditType {
  """"""
  id: ID!

  """"""
  grossAmount: Int!

  """"""
  netAmount: Int!

  """"""
  salesTaxAmount: Int!

  """"""
  note: String!

  """"""
  reason: String!
  metadata: AccountCreditMetadataType
}

type AccountCreditMetadataType {
  """"""
  data: JSONString!

  """"""
  updatedAt: DateTime!
}

"""The input type for the account credit."""
input CreateAccountCreditInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the credit to be created."""
  netAmount: Int!

  """The gross amount of the credit to be created."""
  grossAmount: Int!

  """The sales tax amount of the credit to be created."""
  salesTaxAmount: Int!

  """Any extra data that will be associated with account credit."""
  metadata: JSONString

  """Optional short note about account credit."""
  note: String

  """The reason why the credit is added to the account."""
  reason: AccountCreditReasonType!
}

"""

    Please note: these labels are exposed in the API documentation.
    
"""
enum AccountCreditReasonType {
  """External referral credit"""
  EXTERNAL_REFERRAL_CREDIT
}

"""Add charges to an account."""
type CreateAccountCharge {
  accountCharge: AccountChargeType
}

type AccountChargeType {
  """"""
  id: ID!

  """"""
  grossAmount: Int!

  """Climate change levy"""
  cclAmount: Int!

  """"""
  netAmount: Int

  """"""
  salesTaxAmount: Int

  """"""
  reason: String!

  """"""
  note: String!
  metadata: AccountChargeMetadataType
}

type AccountChargeMetadataType {
  """"""
  data: JSONString!

  """"""
  updatedAt: DateTime!
}

"""The input type for the account charge."""
input CreateAccountChargeInput {
  """The account number."""
  accountNumber: String!

  """The net amount of the charge to be added."""
  netAmount: Int!

  """The gross amount of the charge to be added."""
  grossAmount: Int!

  """The sales tax amount of the charge to be added."""
  salesTaxAmount: Int!

  """The climate change levy amount of the charge to be added."""
  cclAmount: Int

  """Any extra data that will be associated with account charge."""
  metadata: JSONString

  """Optional short note about account charge."""
  note: String

  """The reason why the charge is added to the account."""
  reason: AccountChargeReasonType!
}

"""

    Please note: these labels are exposed in the API documentation.
    
"""
enum AccountChargeReasonType {
  """Default"""
  DEFAULT
}

type FormSubmissionOuput {
  id: Int
  content: JSONString
  errors: [SerializerFieldErrorsType]
}

type SerializerFieldErrorsType {
  field: String
  errors: [ErrorTypeUnion!]
}

union ErrorTypeUnion = SerializerErrorType | SerializerFieldErrorsType

type SerializerErrorType {
  message: String
  code: String
}

input FormSubmissionInput {
  """"""
  accountNumber: String!

  """Form type"""
  formType: FormType

  """Form content"""
  content: JSONString!
}

"""An enumeration."""
enum FormType {
  """Covid-19 Financial Energy Assessment"""
  COVID_19_FINANCIAL_ENERGY_ASSESSMENT

  """Covid-19 Gas Prices Financial Energy Assessment"""
  COVID_19_GAS_PRICES_FINANCIAL_ENERGY_ASSESSMENT
}

type EmailAuthentication {
  token: String
  errors: [ErrorType]
}

type ErrorType {
  field: String!
  messages: [String!]!
}

type APIKeyAuthentication {
  token: String
  errors: [ErrorType]
}

type MasqueradeAuthentication {
  token: String
  errors: [ErrorType]
}

"""
Mutation to generate a pre-signed token.

These pre-signed, expiring and opaque tokens will be swapped
for a limited scope JWT (Kraken Token).
"""
type GeneratePreSignedToken {
  token: String
  tokenExpiryDatetime: DateTime
  scope: PreSignedTokenScope
}

"""

    Choices class for the pre-signed expiring tokens.

    These choices must have a certain format:

    {ACTION-VERB}_{DEFINING-NOUN}

    They should start with an action verb. It should be a single word.
    The action verb enables the account user to do the thing (defining noun)
    that comes after the action verb. Together they represent a task.

    The defining noun could be longer than a single word.
    Preferably, it should be kept short and simple as much as possible.
    
"""
enum PreSignedTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS

  """Edit Customer Marketing Preference"""
  EDIT_CUSTOMER_MARKETING_PREFERENCE
}

"""
Invalidate a previously issued expiring/pre-signed token.

This mutation can be used to invalidate the token itself.  To
invalidate tokens issued to a particular user, use
InvalidatePreSignedTokensForUser.
"""
type InvalidatePreSignedToken {
  token: PreSignedToken
}

"""
A pre-signed, expiring and opaque tokens that can be swapped for a limited scope JWT (Kraken Token).
"""
type PreSignedToken {
  """"""
  key: String!

  """The scope that the token will grant to the account user."""
  scope: ExpiringTokenScope!
  isValid: Boolean
}

"""An enumeration."""
enum ExpiringTokenScope {
  """Scope that enables account user to submit meter readings."""
  SUBMIT_METER_READINGS

  """Scope that enables account user to submit customer feedback."""
  SUBMIT_CUSTOMER_FEEDBACK

  """Scope that enables account user to book smart meter appointments."""
  BOOK_SMART_METER_APPOINTMENTS

  """Edit Customer Marketing Preference"""
  EDIT_CUSTOMER_MARKETING_PREFERENCE
}

"""Input type for the InvalidatePreSignedToken mutation."""
input InvalidatePreSignedTokenInput {
  token: String!
}

"""
Invalidate pre-signed tokens previously issued to a particular user.

This mutation can invalidate all pre-signed tokens issued to a
customer, or only tokens of a given scope.
"""
type InvalidatePreSignedTokensForUser {
  tokens: [PreSignedToken]
}

"""Input type for the InvalidatePreSignedTokensForUser mutation."""
input InvalidatePreSignedTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!

  """
  The scope of the token to invalidate.  If this argument is not specified, all pre-signed tokens issued to the user are invalidated.
  """
  scope: PreSignedTokenScope
}

"""
Mutation to disable the token used to call this mutation. Requires a valid token
for authentication to avoid a potential denial-of-service issue. The token used
for authentication will be the token disabled.
"""
type DisableToken {
  message: String
}

type RequestResetPasswordMutationPayload {
  """"""
  email: String!

  """"""
  isCreateMode: Boolean
  errors: [ErrorType]
  clientMutationId: String
}

input RequestResetPasswordMutationInput {
  """"""
  email: String!

  """"""
  isCreateMode: Boolean
  clientMutationId: String
}

type ResetPasswordMutationPayload {
  errors: [SerializerFieldErrorsType]
  clientMutationId: String
}

input ResetPasswordMutationInput {
  password: String!
  userId: String!
  token: String!
  clientMutationId: String
}

"""
The unifying approach used to get a Kraken token (JWT: JSON Web Token) with
different types of input.

The currently supported inputs are:
- account user email/password combination
- account user API key
- organization live secret key
- pre-signed key
- refresh token
"""
type ObtainKrakenJSONWebToken {
  token: String!
  payload: GenericScalar!
  refreshToken: String
  refreshExpiresIn: Int
}

"""The input type for obtaining a Kraken Token (JWT)."""
input ObtainJSONWebTokenInput {
  """Email address of the account user. Use with 'password' field."""
  email: String

  """Password of the account user. Use with 'email' field."""
  password: String

  """
  API key of the account user. Use standalone, don't provide a second input field.
  """
  APIKey: String

  """
  Live secret key of an third-party organization. Use standalone, don't provide a second input field.
  """
  organizationSecretKey: String

  """
  Short-lived, temporary key (that's pre-signed). Use standalone, don't provide a second input field.
  """
  preSignedKey: String

  """
  The refresh token that can be used to extend the expiry claim of a Kraken token. Use standalone, don't provide a second input field.
  """
  refreshToken: String
}

"""
Obtain a long-lived refresh token.

This mutation is limited to authorized third-party organizations only.

Account users can only generate short-lived refresh tokens.

The short-lived refresh tokens (for account users) can be obtained from
the 'refreshToken' field in 'obtainKrakenToken' mutation.
"""
type ObtainLongLivedRefreshToken {
  refreshToken: String
  refreshExpiresIn: Int!
}

"""The input type for obtaining a long-lived refresh token."""
input ObtainLongLivedRefreshTokenInput {
  """
  The Kraken Token that will be used to generate the long-lived refresh token.
  """
  krakenToken: String!
}

"""
Invalidate a previously issued refresh token.

This mutation can be used to invalidate the token itself.  To
invalidate tokens issued to a particular user, use
InvalidateRefreshTokensForUser.
"""
type InvalidateRefreshToken {
  token: RefreshToken
}

"""An opaque token that can be used to renew a Kraken Token."""
type RefreshToken {
  """"""
  key: String!

  """The datetime when the token will expire."""
  expiryDt: DateTime!
  isValid: Boolean
}

"""Input type for the InvalidateRefreshToken mutation."""
input InvalidateRefreshTokenInput {
  refreshToken: String!
}

"""
Invalidate refresh tokens previously issued to a particular user.

This mutation will invalidate all refresh tokens issued to a
customer.
"""
type InvalidateRefreshTokensForUser {
  tokens: [RefreshToken]
}

"""Input type for the InvalidateRefreshTokensForUser mutation."""
input InvalidateRefreshTokensForUserInput {
  """The email address of the user whose tokens should be invalidated."""
  email: String!
}

"""
Create a shell account (a billable account with no property/energy supply).
"""
type CreateShellAccountPayload {
  """"""
  givenName: String!

  """"""
  familyName: String!

  """"""
  billingName: String

  """"""
  email: String!

  """"""
  mobile: String!

  """"""
  billingAddressLine1: String!

  """"""
  billingAddressLine2: String!

  """"""
  billingAddressLine3: String

  """"""
  billingAddressLine4: String

  """"""
  billingAddressLine5: String

  """"""
  billingPostcode: String!

  """"""
  isBusinessAccount: Boolean

  """"""
  password: String

  """"""
  passwordUpdateToken: String

  """"""
  urn: String
  errors: [ErrorType]
  account: AccountInterface
  clientMutationId: String
}

input CreateShellAccountInput {
  """"""
  givenName: String!

  """"""
  familyName: String!

  """"""
  billingName: String

  """"""
  email: String!

  """"""
  mobile: String!

  """"""
  billingAddressLine1: String!

  """"""
  billingAddressLine2: String!

  """"""
  billingAddressLine3: String

  """"""
  billingAddressLine4: String

  """"""
  billingAddressLine5: String

  """"""
  billingPostcode: String!

  """"""
  isBusinessAccount: Boolean

  """"""
  password: String

  """"""
  passwordUpdateToken: String

  """"""
  urn: String
  clientMutationId: String
}

"""
Update the comms delivery preference for the input account number to the
received commsDeliveryPreference value.
"""
type UpdateCommsDeliveryPreference {
  account: AccountInterface
}

"""Input fields for updating comms delivery preferences for an account"""
input UpdateCommsDeliveryPreferenceInput {
  accountNumber: String!
  commsDeliveryPreference: CommsDeliveryPreference!
}

"""Update address in legacy format for all accounts for user"""
type UpdateUserAddressMutation {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

input UpdateAddressInput {
  """Up to 5 address lines"""
  lines: [String]
  postcode: String
  countryCode: String
  deliveryPointIdentifier: String
}

"""Update address for all accounts for user"""
type UpdateUserRichAddressMutation {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

"""

**⚠️ This type is currently in preview. During this time, it
  may change without warning in backwards-incompatible
  ways.**

A postal address.

This data model is based on the structure used by Google's
[libaddressinput library](https://github.com/google/libaddressinput)&mdash;so
you can use it, or other libraries that use its data model
and reference data, to accept input.

All fields can be blank, except for ``country`` which must
always be supplied.

This type is the input equivalent of `RichAddressType`; all
the fields here are semantically equivalent to fields
there, except where documented.

"""
input RichAddressInput {
  name: String
  organization: String

  """
  
  At most one of this field and `structured_street_address`
  can be supplied.
  
  This is a divergence from `RichAddressType.street_address`,
  where the field is always supplied; if
  `structured_street_address` is present, it's generated from
  that.
  
  """
  streetAddress: String

  """
  
  At most one of this field and `street_address` can be
  supplied.
  
  """
  structuredStreetAddress: GenericScalar
  dependentLocality: String
  locality: String
  administrativeArea: String
  postalCode: String
  sortingCode: String
  country: String
  deliveryPointIdentifier: String
}

"""Update address in legacy format for specified accounts for user"""
type UpdateAccountAddressMutation {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

"""Update address for specified accounts for user"""
type UpdateAccountRichAddressMutation {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

type AddCustomEventMutation {
  """
   Resulting Kraken event 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  event: CustomEventType
}

type CustomEventType {
  """"""
  occurredAt: DateTime!

  """"""
  category: String!

  """"""
  subcategory: String!

  """"""
  content: JSONString
  account: String
}

type CreateAccount {
  account: AccountType
  errors: [ErrorTypeUnion]
}

input CreateAccountInput {
  reference: String!
  soldAt: DateTime!
  accountType: AccountTypeChoices!
  consentData: JSONString
  metaData: JSONString
  affiliate: CreateAccountAffiliateType
  isChangeOfTenancy: Boolean = false
  isMoveIn: Boolean = false
  preferredSsd: Date
  concession: CreateAccountConcessionType
  payment: CreateAccountPaymentType
  billingAddress: CreateAccountAddressType!
  users: [CreateAccountUserType]!
  electricityMeterPoints: [CreateAccountElecMeterPointType]
  gasMeterPoints: [CreateAccountGasMeterPointType]
  lifeSupportRecord: CreateAccountLifeSupportRecordType
}

input CreateAccountAffiliateType {
  referralCode: String = ""
  sessionId: Int
}

input CreateAccountConcessionType {
  cardType: String!
  cardNumber: String
  issueDate: Date
  expiryDate: Date
}

input CreateAccountPaymentType {
  method: String!
  vendor: String
  accountName: String
  accountNumber: String
  accountBsb: String
  paymentDay: Int
  paymentMethodId: String
  cardToken: String
}

input CreateAccountAddressType {
  addressLine1: String!
  addressLine2: String = ""
  addressLine3: String = ""
  suburb: String = ""
  state: String!
  postcode: String!
}

input CreateAccountUserType {
  title: String = ""
  givenName: String!
  familyName: String!
  dateOfBirth: Date
  email: String!
  mobile: String = ""
  landline: String = ""
  optedInToMarketing: Boolean!
}

input CreateAccountElecMeterPointType {
  meterPointIdentifier: String!
  productCode: String!
}

input CreateAccountGasMeterPointType {
  meterPointIdentifier: String!
  productCode: String
  supplyAddress: CreateAccountAddressType
}

input CreateAccountLifeSupportRecordType {
  lifeSupportStatus: String!
  lifeSupportEquipment: String
  lifeSupportDate: Date
  details: String = ""
  preferredContactMethod: String = "SITE_ADDRESS"
  isOwnedByKraken: Boolean = true
}

type UpdateAccountElectricityProduct {
  account: AccountType
  error: AccountProductSwitchingErrorUnion
}

union AccountProductSwitchingErrorUnion = UnsupportedBrandErrorType | MeterPointIdentifierInvalidErrorType | AsOfDateInvalidErrorType | AccountUserIsNotEligibleErrorType | ProductCodeNotFoundErrorType | FailedToRetrieveQuoteErrorType | QuotedProductMissingFromAvailableProductsErrorType | NoMatchingPropertyFromNMIErrorType | FailedToSwitchProductForAccountErrorType | NoMatchingAccountFoundErrorType | CanNotCreateAgreementErrorType

type UnsupportedBrandErrorType implements GenericErrorInterfaceType {
  message: String!
}

type MeterPointIdentifierInvalidErrorType implements GenericErrorInterfaceType {
  message: String!
}

type AsOfDateInvalidErrorType implements GenericErrorInterfaceType {
  message: String!
}

type AccountUserIsNotEligibleErrorType implements GenericErrorInterfaceType {
  message: String!
}

type ProductCodeNotFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type FailedToRetrieveQuoteErrorType implements GenericErrorInterfaceType {
  message: String!
}

type QuotedProductMissingFromAvailableProductsErrorType implements GenericErrorInterfaceType {
  message: String!
}

type NoMatchingPropertyFromNMIErrorType implements GenericErrorInterfaceType {
  message: String!
}

type FailedToSwitchProductForAccountErrorType implements GenericErrorInterfaceType {
  message: String!
}

type NoMatchingAccountFoundErrorType implements GenericErrorInterfaceType {
  message: String!
}

type CanNotCreateAgreementErrorType implements GenericErrorInterfaceType {
  message: String!
}

input UpdateAccountElectricityProductInput {
  userId: Int!
  electricityPlanDetails: ElectricityPlanDetailsType!
  asOf: Date
  requiresPostalComms: Boolean = false
}

input ElectricityPlanDetailsType {
  meterPointIdentifier: String!
  productCode: String!
}

type CreateAccountUser {
  accountUser: AccountUserType
}

input CreateAccountUserInput {
  accountType: AccountTypeChoices!
  givenName: String!
  familyName: String!
  mobile: String!
  landline: String
  email: String

  """
  The customer doesn't have or hasn't provided an email address. If selected, the customer will receive all comms via postal mail for all accounts on their portfolio.
  """
  generateBlackholeEmail: Boolean
  dateOfBirth: Date!

  """
  If the customer specificies which pronouns to use to refer to them, e.g. "she/her" or "them/they" record them here; otherwise leave blank and don't guess.
  """
  pronouns: String
}

type UpdateAccountUserMutationPayload {
  """"""
  givenName: String

  """"""
  familyName: String

  """"""
  pronouns: String

  """"""
  mobile: String

  """"""
  email: String

  """"""
  dateOfBirth: Date

  """"""
  landline: String
  errors: [ErrorType]
  clientMutationId: String
}

input UpdateAccountUserMutationInput {
  """"""
  givenName: String

  """"""
  familyName: String

  """"""
  pronouns: String

  """"""
  mobile: String

  """"""
  email: String

  """"""
  dateOfBirth: Date

  """"""
  landline: String
  clientMutationId: String
}

"""Update the account user comms preferences."""
type UpdateAccountUserCommsPreferencesMutationPayload {
  """"""
  isOptedInToClientMessages: Boolean

  """"""
  isOptedInToOfferMessages: Boolean

  """"""
  isOptedInToRecommendedMessages: Boolean

  """"""
  isOptedInToUpdateMessages: Boolean

  """"""
  isOptedInToThirdPartyMessages: Boolean

  """"""
  isOptedInMeterReadingConfirmations: Boolean

  """"""
  isOptedInToSmsMessages: Boolean

  """"""
  isUsingInvertedEmailColours: Boolean

  """"""
  fontSizeMultiplier: Float

  """"""
  emailFormat: String

  """"""
  preferredHoldMusic: String
  errors: [ErrorType]
  commsPreferences: AccountUserCommsPreferences
  clientMutationId: String
}

input UpdateAccountUserCommsPreferencesMutationInput {
  """"""
  isOptedInToClientMessages: Boolean

  """"""
  isOptedInToOfferMessages: Boolean

  """"""
  isOptedInToRecommendedMessages: Boolean

  """"""
  isOptedInToUpdateMessages: Boolean

  """"""
  isOptedInToThirdPartyMessages: Boolean

  """"""
  isOptedInMeterReadingConfirmations: Boolean

  """"""
  isOptedInToSmsMessages: Boolean

  """"""
  isUsingInvertedEmailColours: Boolean

  """"""
  fontSizeMultiplier: Float

  """"""
  emailFormat: String

  """"""
  preferredHoldMusic: String
  clientMutationId: String
}

"""Update user's password."""
type UpdatePassword {
  """
   The currently authenticated user. 
  
   
  
  This field requires the `Authorization` header to be set. 
  
  
  """
  viewer: AccountUserType
}

input UpdatePasswordInput {
  """Old password"""
  oldPassword: String!

  """New password"""
  newPassword: String!

  """Confirm new password"""
  newPasswordConfirmed: String!
}

type UpdateUserMutation {
  viewer: AccountUserType
}

input UpdateUserInput {
  givenName: String
  familyName: String

  """
  How the user would like us to address them (e.g. 'she/her', 'they/them'). Because this field is clearable, null and the empty string are treated differently; passing null or omitting the field leaves the value as-is, but explicitly passing an empty string clears this value.
  """
  pronouns: String
  email: String
  mobile: String
  dateOfBirth: Date
  landline: String

  """
  The user for whom to perform the update. This is only needed when using an Organisation role
  """
  userId: String
}

type RegisterPushNotificationBinding {
  pushNotificationBinding: PushNotificationBindingType
}

"""Represents a pairing of a single app installation to an account user."""
type PushNotificationBindingType {
  """"""
  id: ID!

  """"""
  messages: [EmailType!]!

  """"""
  user: AccountUserType!

  """"""
  token: String!

  """"""
  application: NotifiableApplicationType!

  """"""
  registeredAt: DateTime!

  """"""
  expiresAt: DateTime!
}

"""Represents an application that can receive push notifications."""
type NotifiableApplicationType {
  """"""
  id: ID!

  """Human readable name for the app."""
  name: String!

  """Bundle ID or package name of the app."""
  bundleId: String!

  """"""
  service: NotifiableApplicationService!

  """"""
  externalProvider: NotifiableApplicationExternalProvider!

  """
  Project ID used in push notification delivery service. (Currently: AWS Pinpoint)
  """
  externalProjectId: String!

  """"""
  description: String!

  """"""
  pushNotificationBindings: [PushNotificationBindingType!]!
}

"""An enumeration."""
enum NotifiableApplicationService {
  """Android (GCM)"""
  GCM

  """iOS (APNs)"""
  APNS

  """iOS Sandbox (APNs Sandbox)"""
  APNS_SANDBOX
}

"""An enumeration."""
enum NotifiableApplicationExternalProvider {
  """AWS Pinpoint"""
  PINPOINT
}

input RegisterPushNotificationBindingInput {
  """Device push notification token."""
  token: String!

  """
  Register a push notification binding. A push notification binding connects an account user to a specific application running on a specific device through a 'registration token' (Android) or 'device token' (iOS). Using this binding we can send push notifications to the account user's devices.
  """
  bundleId: String!
}

"""A charge to the customer."""
type Charge implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in cents after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!

  """
  If this charge is for consumption of a good or service, this field will contain details of how much was consumed. Omitted in cases where the charge is not for consumption, or where consumption information is not available (e.g. for some older records).
  """
  consumption: Consumption

  """If this charge is based on one or more estimated readings."""
  isBasedOnEstimatedReadings: Boolean
}

type Consumption {
  startDate: Date
  endDate: Date
  quantity: Decimal
  unit: ConsumptionUnit
  usageCost: Int
  supplyCharge: Int
}

"""An enumeration."""
enum ConsumptionUnit {
  kWh
  MJ
}

type InvoiceType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
}

"""A payment from the customer to the energy supplier."""
type Payment implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in cents after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

"""A refund to the customer from the energy supplier."""
type Refund implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in cents after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

"""A credit to the customer from the energy retailer."""
type Credit implements TransactionType {
  id: ID
  postedDate: Date

  """Gross amount including tax whenever tax is payable."""
  amount: Int

  """
  The customer's resulting balance in cents after this transaction has been applied.
  """
  balanceCarriedForward: Int

  """Deprecated"""
  isCredit: Boolean

  """Deprecated"""
  isAccountCharge: Boolean

  """Deprecated"""
  isAccountPayment: Boolean

  """
  Whether the statement this transaction is on has been held. A held statement is not sent to a customer automatically, but is instead marked for manual attention by operations staff.
  """
  isHeld: Boolean
  title: String
  statementId: ID
  isReversed: Boolean!
}

type MeasurementType implements MeasurementInterface {
  source: String!
  value: Decimal!
  unit: String!
  readAt: DateTime!
}

type IntervalMeasurementType implements MeasurementInterface {
  source: String!
  value: Decimal!
  unit: String!
  readAt: DateTime!
  startAt: DateTime!
  endAt: DateTime!
  durationInSeconds: Int!
  accumulation: Decimal
}

type PreKrakenBillType implements BillInterface {
  id: ID
  billType: BillTypeEnum
  fromDate: Date
  toDate: Date

  """
  Requesting this field generates a temporary URL at which bill is available.
          This URL will expire after approximately an hour.  It is intended for redirection purposes,
          NOT persistence in any form (e.g. inclusion in emails or the body of a web page).
          This field can raise an error with errorClass NOT_FOUND if the bill document has not
          been created/issued yet.
  
  
          Expected `errorClass`:
  - NOT_FOUND
  - SERVICE_AVAILABILITY
  """
  temporaryUrl: String

  """The date the bill was sent to the customer."""
  issuedDate: Date
  averageDailyUsage: Float
  totalConsumption: Float
  totalConsumptionCost: Float
  totalSupplyCost: Float
  totalFeedInEnergy: Float
  totalFeedInCost: Float

  """
  Whether the bill has been reversed. Null will be returned if this information wasn't sent in through the data import pipeline.
  """
  isReversed: Boolean
}

type GasMeterPointType implements MeterPointInterface {
  id: Int
  meters(id: Int, includeInactive: Boolean): [GasMeterType]
  status: String

  """
  Details about an enrolment of this meter point. Will be null if no enrolment is taking place.
  """
  enrolment: EnrolmentType
  identifier: String

  """The Financially Responsible Organisation status"""
  supplyStatus: KrakenStatus

  """
  A list of agreements belonging to an account that is linked to the logged in user.
  """
  agreements(includeInactive: Boolean = true): [AgreementInterface]

  """The fuel/service type for this meter point."""
  supplyType: String

  """The physical state of the meter point"""
  energizationStatus: GasEnergizationStatus
  distributor: ProviderType
}

type GasMeterType implements Meter {
  id: ID!
  serialNumber: String!

  """"""
  meterTypeSizeCode: String

  """"""
  kpaValue: Decimal

  """"""
  supplyPointIdentifier: String

  """"""
  currentReadDate: Date

  """"""
  currentReadPressureCorrectionFactor: Decimal

  """"""
  nextScheduledReadDate: Date

  """"""
  nextScheduledSpecialRead: Date

  """"""
  meterMultiplier: Decimal

  """"""
  activeFrom: DateTime

  """"""
  activeTo: DateTime

  """The units of consumption for a smart meter."""
  consumptionUnits: String

  """Whether this meter requires a final change of tenancy (COT) reading."""
  requiresCotFinalReading: Boolean

  """The type of fuel this meter uses."""
  fuelType: String

  """Energy consumption recorded by the meter."""
  consumption(
    """Earliest consumption reading to return. Must specify a timezone."""
    startAt: DateTime!

    """Aggregate consumption according to this grouping."""
    grouping: ConsumptionGroupings!

    """Timezone to use for grouping."""
    timezone: String!
    before: String
    after: String
    first: Int
    last: Int
  ): ConsumptionConnection
  status: GasMeterStatus
  meterType: AusGasMeterType
  installationType: GasMeterInstallationType
  meterMeasurementUnit: GasMeterMeasurementUnit
  meterReadFrequency: GasMeterReadFrequency
  readings(includeQuarantined: Boolean = false, before: String, after: String, first: Int, last: Int): GasMeterReadingConnectionTypeConnection
}

"""An enumeration."""
enum GasMeterStatus {
  TURNED_ON
  TURNED_OFF
  PLUGGED
  NO_METER
  TRAILER_AC
  NO_REG
}

"""An enumeration."""
enum AusGasMeterType {
  GAS
  HOT_WATER
}

"""An enumeration."""
enum GasMeterInstallationType {
  MASTER_METER
  SUB_METER
  ORDINARY
}

"""An enumeration."""
enum GasMeterMeasurementUnit {
  METRIC
  IMPERIAL
}

"""An enumeration."""
enum GasMeterReadFrequency {
  BI_MONTHLY
  DAILY
  MONTHLY
  QUARTERLY
}

"""


This field is a connection type. Connections are used to implement [cursor based pagination](https://graphql.org/learn/pagination/#pagination-and-edges).


"""
type GasMeterReadingConnectionTypeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [GasMeterReadingConnectionTypeEdge]!
}

"""
A Relay edge containing a `GasMeterReadingConnectionType` and its cursor.
"""
type GasMeterReadingConnectionTypeEdge {
  """The item at the end of the edge"""
  node: GasMeterReadingType

  """A cursor for use in pagination"""
  cursor: String!
}

"""

A reading from an Australian gas meter, as Kraken receives
it from industry.

"""
type GasMeterReadingType {
  """"""
  id: ID!

  """"""
  meter: GasMeterType!

  """"""
  value: Decimal!

  """"""
  readAt: DateTime!

  """"""
  typeOfRead: ReadingTypeOfRead

  """"""
  reasonForRead: ReadingReasonForRead

  """"""
  volumeFlow: Decimal

  """"""
  gasMeterUnits: ReadingGasMeterUnits

  """"""
  averageHeatingValue: Decimal

  """"""
  pressureCorrectionFactor: Decimal

  """"""
  consumedEnergy: Decimal
}

"""An enumeration."""
enum ReadingTypeOfRead {
  """Actual"""
  A

  """Estimated"""
  E

  """Substituted"""
  S

  """Customer Own Read"""
  C
}

"""An enumeration."""
enum ReadingReasonForRead {
  """Special Final Read"""
  SRF

  """Special Reference Read"""
  SRR

  """Special Account Investigation"""
  SRA

  """Special Disconnection"""
  SRD

  """Special Transfer Read"""
  SRT

  """Schedule Cycle Read"""
  SCH

  """Meter Installation Read"""
  INI

  """Meter Removed Read"""
  REM

  """Other Service Order"""
  OSO

  """Meter Data Verify"""
  MDV
}

"""An enumeration."""
enum ReadingGasMeterUnits {
  """Metric"""
  M

  """Imperial"""
  I
}

"""An enumeration."""
enum GasEnergizationStatus {
  Registered
  Commissioned
  Decommissioned
  Deregistered
  Unclaimed
}

type ProviderType {
  id: String!
  shortName: String!
  longName: String!
  displayName: String!
  emergencyPhoneNumber: String!
  outagePhoneNumber: String
}

type GasAgreementType implements AgreementInterface {
  id: Int
  validFrom: DateTime
  validTo: DateTime

  """"""
  agreedAt: DateTime

  """"""
  terminatedAt: DateTime
  agreedFrom: DateTime
  agreedTo: DateTime
  isRevoked: Boolean
  product: Product
  supplyType: String
  isActive: String
  meterPoint: GasMeterPointType
}

"""
Product rates for electricity may be matched to registers using the network tariff code and time of day.
"""
type ElectricityRateType implements RateInterface {
  currency: String
  bandCategory: String

  """Unit cost before tax."""
  rateExcludingTax: Float!

  """Unit cost including tax."""
  rateIncludingTax: Float!

  """Description that will show up on the customer's bill"""
  rateDescription: String
  validFrom: DateTime
  validTo: DateTime

  """Start of the step the rate applies to."""
  stepStart: Float

  """End of the step the rate applies to (Exclusive)."""
  stepEnd: Float

  """Accumulation meters use the `ALLDAY` product rates."""
  timeOfDay: String

  """Matches the Network Tariff Codes published by each LNSP."""
  networkTariffCode: String

  """Description for the network tariff code"""
  chargeDescription: String
}

"""Product rates for gas."""
type GasRateType implements RateInterface {
  currency: String
  bandCategory: String

  """Unit cost before tax."""
  rateExcludingTax: Float!

  """Unit cost including tax."""
  rateIncludingTax: Float!

  """Description that will show up on the customer's bill"""
  rateDescription: String
  validFrom: DateTime
  validTo: DateTime

  """Start of the step the rate applies to."""
  stepStart: Float

  """End of the step the rate applies to (Exclusive)."""
  stepEnd: Float
  pricingZone: PricingZone
}

"""An enumeration."""
enum PricingZone {
  AGLNSW
  TAMWORTH
  APTALLGAS
  ACTEWAGL
  COOMABOMBA
  ALBURY
  MURYVALLEY
  TEMORA_HHOLCWALLA
  WAGGAURANQ
  TUMUTGUNDA
  TRUEAST_OESTHEAST
  AGLNORTH_TRUCENTRAL
  OEMETRO_AGLSOUTH
  TRURCBARWN
  TRUWEST
  TRURULWEST
  MILDURA
  OENORTH
  OEMURVLYV
  OEWGPLAND
  OEBRNSDALE
  BRISNORTH
  WIDEBAY
  QLDNORTH
  AGNSA
  MIDWSOUTHW
  ALICESPNGS
  OEYRVALLEY
}
